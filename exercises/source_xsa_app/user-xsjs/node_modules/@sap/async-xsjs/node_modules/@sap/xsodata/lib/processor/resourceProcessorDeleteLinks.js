'use strict';

var async = require('async');
var connect = require('../db/connect');
var sqlDeleteLinks = require('./../sql/createDeleteLinksStatements');
var dataCollectorLinks = require('./../sql/dataCollectorLinks');
var dataCollectorDeleteLinks = require('./../sql/dataCollectorDeleteLinks');
var serializer = require('./../serializer/serializer');
var exitProcessor = require('./exitProcessor');
var utils = require('./../utils/utils');


function eventBefore(context, asyncDone) {
	var eventFunction = exitProcessor.eventHandler('before', 'delete');

	context.logger.info('delete', 'event start before');
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'before');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventAfter(context, asyncDone) {
	var eventFunction = exitProcessor.eventHandler('after', 'delete');

	context.logger.info('delete', 'event start after');
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'after');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventPrecommit(context, asyncDone) {
	var eventFunction = exitProcessor.eventHandler('precommit', 'delete');

	context.logger.info('delete', 'event start precommit');
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'precommit');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function eventPostCommit(context, asyncDone) {
	var eventFunction = exitProcessor.eventHandler('postcommit', 'delete');

	context.logger.info('delete', 'event start postcommit');
    eventFunction(context, function (err, context) {
        context.logger.info('modify event end', 'postcommit');
        if (err) {
            context.logger.info('modify event end', 'error occured');
        }
        return asyncDone(err, context);
    });
}

function insertTmpTableToRealTable(context, asyncDone) {
    var dbSeg = context.oData.dbSegmentLast;
    var entityType = dbSeg.entityType;
    var create = (entityType.modifications || {} ).update || {};

    if (create.using) {
        exitProcessor.executeExit(create.using, 'using', 'delete', context, asyncDone);
    } else {
        dataCollectorLinks.insertTmpTableToRealTable(context, asyncDone);
    }
}

function executeDelete(context, asyncDone) {
    var dbSeg = context.oData.dbSegmentLast;
    var entityType = dbSeg.entityType;
    var _delete = (entityType.modifications || {} )['delete'] || {};
    if (_delete.using) {
        exitProcessor.executeExit(_delete.using, 'using', 'delete', context, asyncDone);
    } else {
        dataCollectorDeleteLinks.deleteTable(context, asyncDone);
    }
}

function setStatus(context, asyncDone) {
    context.response.status(204);
    return asyncDone(null, context);
}

exports.process = function (context, asyncDone) {
    var execArr;
	var m2n = (context.oData.dbSegmentLast.getOver()!==undefined);

	context.logger.silly('resourceProcessorDeleteLinks', 'process');

	if (m2n) { // INSERT into 3rd table
        context.oData.dbSegmentLast.m2n = true;
        execArr = [
            utils.injectContext(context),

            //preparation
            utils.try(sqlDeleteLinks.createDeleteLinksMNStatementsCreateTmpTables),
            utils.try(dataCollectorLinks.createTmpTableMN), //create //NEW ORL

            // no payload for delete link
            utils.try(sqlDeleteLinks.createDeleteLinksMNStatementsInsert),
            utils.try(dataCollectorLinks.insertOldDataToPrincipalDependentTables),
            utils.try(dataCollectorDeleteLinks.insertDataToDelTable), //insert NEW

            //execution
            utils.try(eventBefore),
            utils.try(executeDelete),
            utils.try(eventAfter),

            //commit handling
            utils.try(eventPrecommit),
            utils.try(dataCollectorLinks.commit),
            utils.try(eventPostCommit),

            // cleanup
            utils.try(dataCollectorLinks.truncateTempTablesMN),
            utils.try(dataCollectorLinks.dropTempTablesMN),
            utils.try(dataCollectorLinks.commit),

            utils.try(setStatus)
        ];
    } else {
        execArr = [
            utils.injectContext(context),

            //preparation
            utils.try(sqlDeleteLinks.createDeleteLinksStatementsCreateTmpTables),
            utils.try(dataCollectorLinks.createTmpTables),

            // no payload for delete link
            utils.try(sqlDeleteLinks.createDeleteLinksStatementsInsert),
            utils.try(dataCollectorLinks.moveRecordNV_ToSelectStm),

            utils.try(dataCollectorLinks.insertOldDataToOldTable),
            utils.try(dataCollectorLinks.insertOldDataToPrincipalDependentTables),
            utils.try(dataCollectorLinks.insertPayloadIntoTempTable),

            //execution
            utils.try(eventBefore),
            utils.try(insertTmpTableToRealTable),
            utils.try(eventAfter),

            //commit handling
            utils.try(eventPrecommit),
            utils.try(dataCollectorLinks.commit),
            utils.try(eventPostCommit),

            // cleanup
            utils.try(dataCollectorLinks.truncateTempTables),
            utils.try(dataCollectorLinks.dropTempTables),
            utils.try(dataCollectorLinks.commit),

            //post processing
            utils.try(serializer.serializeNoContent)
        ];
    }

    async.waterfall(
        execArr,
        function (err, context) {
            if (err) {
                var dbClient = context.db.client;
                if (dbClient) {
                    //ROLLBack the changes
                    return connect.dbRollback(context, dbClient, function (errDB) {
                        if (errDB) {
                            return asyncDone(errDB, context);
                        }

                        return asyncDone(err, context);
                    });
                }
            }
            return asyncDone(err, context);
        }
    );
};


exports.processInBatchCreateTables = function (context, asyncDone) {
    context.logger.silly('resourceProcessorDeleteLinks', 'processInBatchCreateTables');

    var execArr;
    var m2n = (context.oData.dbSegmentLast.getOver()!==undefined);
    if (m2n) { // INSERT into 3rd table
        context.oData.dbSegmentLast.m2n = true;
        execArr = [
            utils.injectContext(context),

            //preparation
            utils.try(sqlDeleteLinks.createDeleteLinksMNStatementsCreateTmpTables),
            utils.try(dataCollectorLinks.createTmpTableMN)
        ];
    }
    else {
        execArr = [
            utils.injectContext(context),

            //preparation
            utils.try(sqlDeleteLinks.createDeleteLinksStatementsCreateTmpTables),
            utils.try(dataCollectorLinks.createTmpTables) //create //NEW ORL
        ];
    }

    async.waterfall(
        execArr,
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};

exports.processInBatch = function (context, asyncDone) {
    context.logger.silly('resourceProcessorDeleteLinks', 'processInBatch');

    var execArr;
    var m2n = (context.oData.dbSegmentLast.getOver()!==undefined);
    if (m2n) { // INSERT into 3rd table
        context.oData.dbSegmentLast.m2n = true;
        execArr = [
            utils.injectContext(context),

            //preparation
            // no payload for delete link
            utils.try(sqlDeleteLinks.createDeleteLinksMNStatementsInsert),
            utils.try(dataCollectorLinks.insertOldDataToPrincipalDependentTables),
            utils.try(dataCollectorDeleteLinks.insertDataToDelTable),

            //execution
            utils.try(eventBefore),
            utils.try(executeDelete), //insert real
            utils.try(eventAfter)
        ];
    }
    else {
        execArr = [
            utils.injectContext(context),

            //preparation
            // no payload for delete link
            utils.try(sqlDeleteLinks.createDeleteLinksStatementsInsert),
            utils.try(dataCollectorLinks.moveRecordNV_ToSelectStm), //no change
            utils.try(dataCollectorLinks.insertOldDataToOldTable),
            utils.try(dataCollectorLinks.insertOldDataToPrincipalDependentTables),
            utils.try(dataCollectorLinks.insertPayloadIntoTempTable), //insert NEW

            //execution
            utils.try(eventBefore),
            utils.try(insertTmpTableToRealTable),
            utils.try(eventAfter)
        ];
    }

    async.waterfall(
        execArr,
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};


exports.processInBatchPreCommitRun = function (context, asyncDone) {
    context.logger.silly('resourceProcessorDeleteLinks', 'processInBatchPreCommitRun');

    async.waterfall(
        [
            utils.injectContext(context),

            utils.try(eventPrecommit)
        ],

        function (err, context) {
            return asyncDone(err, context);
        }
    );
};

exports.processInBatchPostCommitRun = function (context, asyncDone) {
    context.logger.silly('resourceProcessorDeleteLinks', 'processInBatchPostCommitRun');

    async.waterfall(
        [
            utils.injectContext(context),

            utils.try(eventPostCommit),

            // cleanup
            utils.try(dataCollectorLinks.truncateTempTables),
            utils.try(dataCollectorLinks.dropTempTables),

            //post processing
            utils.try(serializer.serializeNoContent)
        ],
        function (err, context) {
            return asyncDone(err, context);
        }
    );
};
