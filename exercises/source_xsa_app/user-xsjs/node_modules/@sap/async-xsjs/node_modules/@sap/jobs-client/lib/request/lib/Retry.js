
const timers = new Map();

const defaultTimeoutStrategy = (tryCount) => {
    if (tryCount > 5) return Retry.getRandomInt(60000, 90000);
    if (tryCount > 3) return Retry.getRandomInt(30000, 45000);
    if (tryCount > 1) return Retry.getRandomInt(15000, 25000);
    if (tryCount > 0) return Retry.getRandomInt(5000, 10000);
    return Retry.getRandomInt(5000, 10000);
};

class Retry {

    static stop() {
        timers.forEach((timer, retry) => {
            retry.intercept();
            clearTimeout(timer);
        });
        timers.clear();
    }

    static getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min)) + min;
    }

    constructor(maxTryCount = 8, timeoutStrategy = defaultTimeoutStrategy) {
        this._tryCount = 0;
        this._maxTryCount = maxTryCount;
        this._timeoutStrategy = timeoutStrategy;
    }

    getTimeout(tryCount) { return this._timeoutStrategy(tryCount); }

    getTryCount() { return this._tryCount; }

    getMaxTryCount() { return this._maxTryCount; }

    intercept() {
        this._intercepted = true;
        clearTimeout(timers.get(this));
        timers.delete(this);
        return this;
    }

    isIntercepted() { return this._intercepted === true; }

    getCatch() { return this._catch; }

    async try(onTry, onCatch) {

        if (this.isIntercepted()) throw new Error('Retry was intercepted.');

        this._tryCount++;

        try {
            return await onTry(this._tryCount, this.getMaxTryCount());
        } catch (error) {
            if (this._tryCount >= this.getMaxTryCount()) {
                throw error;
            }

            const timeout = this.getTimeout(this._tryCount);

            if (onCatch) {
                await onCatch(error, this._tryCount, timeout);
            }

            await new Promise((resolve) => {
                const timer = setTimeout((_timers, _this, _resolve) => {
                    _timers.delete(_this);
                    _resolve();
                }, timeout, timers, this, resolve); // do not use unref!!!
                timers.set(this, timer);
            });

            return await this.try(onTry, onCatch);
        }
    }

}

module.exports = Retry;
