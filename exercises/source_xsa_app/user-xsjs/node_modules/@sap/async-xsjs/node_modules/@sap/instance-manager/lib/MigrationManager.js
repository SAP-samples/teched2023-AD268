'use strict';

var Cache = require('lru-cache');
var debug = require('debug')('instance-manager');

var userInput = require('./user-input');
var INSTANCE = require('./instance-manager/constants').STATUS.INSTANCE;
var InstanceManager = require('./instance-manager/Backend');
var ServiceManager = require('./service-manager/Backend');

module.exports = MigrationManager;

function MigrationManager(options) {
  if (!options.imOpts && !options.smOpts) {
    return new Error('You have to provide credentials for both Instance and Service manager');
  }
  var imOpts = userInput.processMainOptions(options.imOpts);
  var smOpts = userInput.processMainOptions(options.smOpts);
  this._backendSM = new ServiceManager(smOpts);
  this._backendIM = new InstanceManager(imOpts);
  // Cache settings are the same for both Instance and Service manager.
  this._cache = new Cache({ max: imOpts.cache_max_items, maxAge: (imOpts.cache_item_expire_seconds * 1000) });
}

MigrationManager.prototype.init = function (callback) {
  this._backendSM.init(callback);
};

MigrationManager.prototype.create = function (tenant, arg2, arg3) {
  var callback = arg3 || arg2;
  var optionalParameters = arg3 ? arg2 : null;

  tenant = userInput.processTenant(tenant);
  optionalParameters = userInput.processOptionalParameters(optionalParameters);

  var self = this;
  self._backendSM.create(tenant, optionalParameters, function (err, instance) {
    if (err) {
      return callback(err);
    }

    self._cache.set(instance.tenant_id, instance);
    callback(null, instance);
  });
};

MigrationManager.prototype.get = function (tenant, optionalParameters, callback) {
  if (!callback) {
    callback = optionalParameters;
    optionalParameters = undefined;
  }
  if (optionalParameters) {
    optionalParameters = userInput.processOptionalParameters(optionalParameters);
  }
  tenant = userInput.processTenant(tenant);
  var self = this;

  if (self._cache.has(tenant)) {
    debug("Getting instance for tenant '%s' from cache", tenant);
    var instance = self._cache.get(tenant);
    return process.nextTick(function () { callback(null, instance); });
  }
  self._backendSM.get(tenant, optionalParameters, function (err, instance) {
    if (err) {
      debug("An error '%s' occurred trying to get instance for tenant '%s' from SM. Attempting to retrieve instance from IM.", err, tenant);
      return self._backendIM.get(tenant, callback);
    }
    if (instance === null) {
      debug('No instance found.');
      return self._backendIM.get(tenant, callback);
    }
    return callback(err, instance);
  });
};

MigrationManager.prototype.getAll = function (optionalParameters, callback) {
  if (!callback) {
    callback = optionalParameters;
    optionalParameters = undefined;
  }
  if (optionalParameters) {
    optionalParameters = userInput.processOptionalParameters(optionalParameters);
  }
  var self = this;
  self._backendSM.getAll(optionalParameters, function (smErr, sMInstances) {
    self._backendIM.getAll(function (imErr, iMInstances) {
      if (imErr && smErr) {
        let message  = `${smErr.message} - ${imErr.message}`;
        return callback(new Error(message));
      } else if (imErr) {
        debug("An error '%s' occurred trying to get all instances from IM", imErr);
      } else if (smErr) {
        debug("An error '%s' occurred trying to get all instances from SM", smErr);
      }
      sMInstances = sMInstances || [];
      iMInstances = iMInstances || [];
      var instances = sMInstances.concat(iMInstances.filter((imItem) => !sMInstances.find((smItem) => smItem.tenant_id === imItem.tenant_id)));
      refreshCache(self._cache, instances);
      return callback(null, instances);
    });
  });
};

MigrationManager.prototype.delete = function (tenant, callback) {
  tenant = userInput.processTenant(tenant);

  var self = this;

  self._backendIM.delete(tenant, function (imErr) {
    self._backendSM.delete(tenant, function (smErr) {
      if (imErr && smErr) {
        let message  = `${smErr.responseDescription} *** ${imErr.responseDescription}`;
        let error = new Error(message);
        // Maybe reconsider this, since 404 might mean deletion was already completed.       
        if (smErr.responseStatusCode === undefined){
          smErr.statusCode = 404;
          smErr.responseStatusCode = 404;
        }
        error.statusCode = smErr.statusCode < imErr.statusCode ? imErr.statusCode : smErr.statusCode;
        error.responseStatusCode = smErr.statusCode < imErr.statusCode ? imErr.statusCode : smErr.statusCode;
        return callback(error);
      } else if (imErr) {
        debug("An error '%s' occured trying to delete instance from IM", imErr);
      } else if (smErr) {
        debug("An error '%s' occured trying to delete instance from SM", smErr);
      }
      self._cache.del(tenant);
      debug("'%s' has been successfully deleted", tenant);
      callback();
    });
  });
};

function refreshCache(cache, instance) {
  cache.reset();
  instance.filter(function (instace) {
    return instace.status === INSTANCE.CREATEED;
  }).forEach(function (instance) {
    cache.set(instance.tenant_id, instance);
  });
}

