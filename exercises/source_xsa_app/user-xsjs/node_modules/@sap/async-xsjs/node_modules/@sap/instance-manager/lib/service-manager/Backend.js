'use strict';

var crypto = require('crypto');
var format = require('util').format;

var clone = require('clone');
var uuid = require('uuid');
var debug = require('debug')('instance-manager');

var Client = require('./Client');
var userInput = require('./user-input');
var Polling = require('../PollingSession');
var LIBRARY = require('./constants').LIBRARY;
var HTTP = require('./constants').STATUS.HTTP;
var TIME_PROPERTY = require('./constants').TIME_PROPERTY;
var INSTANCE = require('../instance-manager/constants').STATUS.INSTANCE;

module.exports = Backend;

function Backend(options) {
  var opts = userInput.processMainOptions(options);

  this._options = opts;
  this._client = new Client(opts);

  this._serviceMetadata = { label: opts.service, plan: opts.plan };
  this._servicePlanId = null;
}

Backend.prototype.init = function (cb) {
  var self = this;
  this._client.getServiceOffering(this._options.service, function (err, serviceOffering) {
    if (err) {
      return cb(err);
    }

    self._serviceMetadata.tags = serviceOffering.tags;

    self._client.getServicePlan(self._options.plan, serviceOffering.id, function (err, servicePlan) {
      if (err) {
        return cb(err);
      }

      self._servicePlanId = servicePlan.id;

      cb();
    });
  });
};

Backend.prototype.create = function (tenant, params, cb) {
  var self = this;
  var polling = new Polling(tenant, this._options.polling_interval_millis, this._options.polling_timeout_seconds);

  this._createInstance(tenant, params, polling, function (err, instanceOperation) {
    if (err) {
      return cb(ErrorInfo(err));
    }

    let instanceId = instanceOperation.resource_id;
    self._createBinding(tenant, params, instanceId, polling, function (err, bindingOperation) {
      if (err) {
        return self._client.deleteInstance(instanceId, polling, function (rollbackError) {
          if (rollbackError) {
            debug('Unsuccessful rollback for tenant %s: %j', tenant, rollbackError);
            err.message += ', rollback error: ' + rollbackError.message;
            cb(err);
          } else {
            debug('Successful rollback for tenant %s', tenant);
            cb(err);
          }
        });
      }

      self._client.getBindingById(bindingOperation.resource_id, function (err, binding) {
        if (err) {
          return cb(ErrorInfo(err));
        }

        cb(null, self._toManagedInstance(binding));
      });
    });
  });
};

Backend.prototype.delete = function (tenant, cb) {
  var self = this;
  var polling = new Polling(tenant, this._options.polling_interval_millis, this._options.polling_timeout_seconds);

  self._deleteBindings(tenant, polling, function (err) {
    if (err) {
      return cb(ErrorInfo(err));
    }

    // implement the callback in order to not forward the operation argument
    // that it would receive
    self._deleteInstance(tenant, polling, function (err) {
      if (err) {
        return cb(ErrorInfo(err));
      }

      cb();
    });
  });
};

Backend.prototype.getAll = function (params, cb) {
  if (!cb) {
    cb = params;
    params = {};
  }
  var self = this;
  this._getInstances(null, function(err, instances) {
    if (err) {
      debug('Unable to retrieve all instances, error: %s', err);
      return cb(ErrorInfo(err));
    }
    self._getBindings(null, function(err2, bindings) {
      if (err2) {
        debug('Unable to retrieve all bindings, error: %s', err2);
        return cb(err2);
      }

      let result = [];
      let bindingTenants = Object.keys(bindings);
      bindingTenants.forEach(tenant => {
        var latestReadyBinding = findLatestReady(bindings[tenant]);
        if (latestReadyBinding) {
          result.push(self._toManagedInstance(latestReadyBinding));
        } else {
          debug('No ready binding for tenant %s', tenant);
        }
      });

      let instanceTenants = Object.keys(instances);
      let instanceTenantsWithoutBinding = extractInstanceTenantsWithoutBinding(instanceTenants, bindingTenants);
      let processedInstanceWithoutBinding = 0;

      for (let i = 0; i < instanceTenantsWithoutBinding.length; i++) {
        const tenant = instanceTenants[i];
        if (!instances[tenant][0].ready) {
          instanceTenantsWithoutBinding.splice(i, 1);
          i--;
        }
      }

      if (instanceTenantsWithoutBinding.length === 0) {
        return cb(null, result);
      }

      if (!self._options.allowBinding)
      {
        debug('Automatic binding creation is disabled. List of instanceTenantsWithoutBinding: ', instanceTenantsWithoutBinding);
        return cb (null, result);
      } else {
        instanceTenantsWithoutBinding.forEach(tenant => {
          let instance = instances[tenant][0];
          let instanceId = instance.id;
          let polling = new Polling(tenant, self._options.polling_interval_millis, self._options.polling_timeout_seconds);
          self._createBinding(tenant, params, instanceId, polling, function (bindingErr, bindingOperation) {
            if (bindingErr) {
              debug(format('Unable to create binding for tenant %s, error: %s', tenant, bindingErr));
              processedInstanceWithoutBinding++;
            }
            else {
              self._client.getBindingById(bindingOperation.resource_id, function (getBindingErr, binding) {
                processedInstanceWithoutBinding++;
                if (getBindingErr) {
                  debug(format('Unable to retrieve newly created binding for tenant %s, error: %s', tenant, getBindingErr));
                }
                else if (!binding.ready) {
                  debug('Newly created binding not ready for tenant %s', tenant);
                }
                else {
                  result.push(binding);
                }

                if (processedInstanceWithoutBinding === instanceTenantsWithoutBinding.length) {
                  return cb(null, result);
                }
              });
            }

            if (processedInstanceWithoutBinding === instanceTenantsWithoutBinding.length) {
              return cb(null, result);
            }
          });
        });
      }
    });
  });
};

Backend.prototype.get = function (tenant, params, cb) {
  // Backwards compatible.
  if (!cb) {
    cb = params;
    params = {};
  }
  var self = this;
  var polling = new Polling(tenant, this._options.polling_interval_millis, this._options.polling_timeout_seconds);
  this._getBindings(tenant, function (err, bindings) {
    if (err) {
      return cb(ErrorInfo(err));
    }

    var bindingsForTenant = bindings[tenant];
    if (bindingsForTenant) {
      var latestReady = findLatestReady(bindingsForTenant);
      if (latestReady) {
        return cb(null, self._toManagedInstance(latestReady));
      }

      return cb(new Error(format('There are available bindings but none are ready for tenant %s', tenant)));
    }

    debug('No bindings for tenant %s are available', tenant);
    self._client.getInstanceByName(self._instanceName(tenant), function (err, instance) {
      if (err) {
        return cb(err);
      }

      if (!instance) {
        debug('No instance for tenant %s is available', tenant);
        return cb(null, null);
      }

      if (!instance.ready) {
        debug('Instance is available however it is not ready.');
        return cb(null, null);
      }
      if (!self._options.allowBinding)
      {
        debug('No bindings for tenant %s are available and creation is disabled', tenant);
        return cb(null, null);
      }
      else {
        let instanceId = instance.id || instance.resource_id;
        self._createBinding(tenant, params, instanceId, polling, function (err, bindingOperation) {
          if (err) {
            return cb(ErrorInfo(err));
          }

          self._client.getBindingById(bindingOperation.resource_id, function (err, binding) {
            if (err) {
              return cb(ErrorInfo(err));
            }

            cb(null, self._toManagedInstance(binding));
          });
        });
      }
    });
  });
};

Backend.prototype._createInstance = function (tenant, params, polling, cb) {
  var options = {
    'name': this._instanceName(tenant),
    'service_plan_id': this._servicePlanId
  };

  var labels = { 'tenant_id': [tenant] };
  options.labels = labels;

  if (params && params.provisioning_parameters) {
    options.parameters = params.provisioning_parameters;
  }

  this._client.createInstance(options, polling, cb);
};

Backend.prototype._createBinding = function (tenant, params, instanceId, polling, cb) {
  var options = {
    'name': this._bindingName(),
    'service_instance_id': instanceId
  };

  var labels = { 'tenant_id': [tenant], 'service_plan_id': [this._servicePlanId] };
  labels[LIBRARY.LABEL_KEY] = [LIBRARY.LABEL_VALUE];
  options.labels = labels;

  if (params && params.binding_parameters) {
    options.parameters = params.binding_parameters;
  }

  this._client.createBinding(options, polling, cb);
};

Backend.prototype._deleteBindings = function (tenant, polling, cb) {
  var self = this;
  this._getBindings(tenant, function (err, bindings) {
    if (err) {
      return cb(ErrorInfo(err));
    }

    var tenantBindings = bindings[tenant];

    if (!tenantBindings) {
      // Allow no bindings.
      // Deleting a managed instance consists of deleting a binding and an instance in Service Manager.

      // If deleting of the binding fails, the instance cannot be deleted since a binding for it still exists.
      // Orphant mitigation of Service Manager will remove the binding, but will keep the instance.
      // Allow applications to attempt the deletion of the managed instance again - the binding might not be present, but the instance can still be there.

      // If deleting the binding succeeds, but the deletion of the instance fails, applications can still be able to retry the operation
      // (having in mind we do not treat the absence of the binding as error).
      return cb();
    }

    self._deleteListedBindings(tenantBindings, polling, cb);
  });
};

Backend.prototype._deleteListedBindings = function (bindings, polling, cb) {
  if (bindings.length === 0) {
    return cb();
  }

  var binding = bindings.shift();

  var self = this;
  this._client.deleteBinding(binding.id, polling, function (err) {
    if (err) {
      return cb(ErrorInfo(err));
    }

    self._deleteListedBindings(bindings, polling, cb);
  });
};

Backend.prototype._deleteInstance = function (tenant, polling, cb) {
  var self = this;
  this._client.getInstanceByName(this._instanceName(tenant), function (err, instance) {
    if (err) {
      return cb(ErrorInfo(err));
    }

    if (!instance) {
      // for compatibility with instance manager implementation:
      // when application attempts managed instance deletion
      // when relevant resources are already deleted - return error with statusCode 404
      var error = new Error('Missing managed service instance for tenant ' + tenant);
      error.statusCode = HTTP.NOT_FOUND;
      error.responseDescription = 'Missing managed service instance for tenant ' + tenant;
      error.responseStatusCode = 404;
      return cb(error);
    }

    self._client.deleteInstance(instance.id, polling, cb);
  });
};

Backend.prototype._instanceName = function (tenant) {
  var str = this._servicePlanId + '_' + tenant;
  var digest = crypto.createHash('sha256').update(str).digest('base64');
  return digest;
};

Backend.prototype._bindingName = function () {
  return uuid.v4();
};

Backend.prototype._getBindings = function (tenant, cb) {
  var labelQuery = format("service_plan_id eq '%s' and %s eq '%s'",
    this._servicePlanId, LIBRARY.LABEL_KEY, LIBRARY.LABEL_VALUE);

  if (tenant) {
    labelQuery += format(" and tenant_id eq '%s'", tenant);
  }

  this._client.getBindings({ labelQuery: labelQuery }, function (err, bindings) {
    if (err) {
      return cb(err);
    }

    if (bindings.length === 0) {
      return cb(null, {});
    }

    var grouped = groupByTenant(bindings);
    var tenants = Object.keys(grouped);

    for (var i = 0; i < tenants.length; ++i) {
      var tenant = tenants[i];
      var tenantBindings = grouped[tenant];
      var validationError = validateTimestamps(tenantBindings);
      if (validationError) {
        return cb(validationError);
      }
      grouped[tenant] = sortByTimestamp(tenantBindings);
    }

    cb(null, grouped);
  });
};

Backend.prototype._getInstances = function (tenant, cb) {
  var fieldQuery = format("service_plan_id eq '%s'", this._servicePlanId);

  if (tenant) {
    fieldQuery += format(" and tenant_id eq '%s'", tenant);
  }

  this._client.getInstances({ fieldQuery: fieldQuery }, function (err, instances) {
    if (err) {
      return cb(ErrorInfo(err));
    }

    if (instances.length === 0) {
      return cb(null, {});
    }

    var grouped = groupByTenant(instances);
    var tenants = Object.keys(grouped);
    for (var i = 0; i < tenants.length; ++i) {
      var tenant = tenants[i];
      var tenantBindings = grouped[tenant];
      var validationError = validateTimestamps(tenantBindings);
      if (validationError) {
        return cb(validationError);
      }
      grouped[tenant] = sortByTimestamp(tenantBindings);
    }
    cb(null, grouped);
  });
};

Backend.prototype._toManagedInstance = function (binding) {
  var managedInstance = clone(this._serviceMetadata);
  managedInstance['credentials'] = binding.credentials;
  managedInstance['tenant_id'] = binding.labels['tenant_id'][0];
  managedInstance['status'] = INSTANCE.CREATED;
  return managedInstance;
};

function groupByTenant(bindings) {
  var byTenant = {};
  bindings.forEach(function (binding) {
    var tenant = binding.labels && binding.labels['tenant_id'] && binding.labels['tenant_id'][0];
    if (!tenant) {
      debug('Omitting binding with id %s and name %s - it does not have a tenant_id label', binding.id, binding.name);
      return;
    }

    if (byTenant[tenant]) {
      byTenant[tenant].push(binding);
    } else {
      byTenant[tenant] = [binding];
    }
  });
  return byTenant;
}

function validateTimestamps(bindings) {
  for (var i = 0; i < bindings.length; ++i) {
    var binding = bindings[i];
    var value = binding[TIME_PROPERTY];
    var time = new Date(value).getTime();
    if (isNaN(time)) {
      return new Error(format('Property %s does not represent a valid timestamp: %s, binding id: %s, binding name: %s',
        TIME_PROPERTY, value, binding.id, binding.name));
    }
  }
}

function sortByTimestamp(bindings) {
  return bindings.sort(function (a, b) {
    var aTime = new Date(a[TIME_PROPERTY]).getTime();
    var bTime = new Date(b[TIME_PROPERTY]).getTime();
    return bTime - aTime;
  });
}

function findLatestReady(bindings) { // assumes bindings are sorted by time in descending order
  for (var i = 0; i < bindings.length; ++i) {
    var binding = bindings[i];
    if (binding.ready) {
      return binding;
    } else {
      debug('Skipping binding with id %s and name %s - not ready', binding.id, binding.name);
    }
  }
  return null;
}


function extractInstanceTenantsWithoutBinding(instanceTenants, bindingTenants) {
  let instanceTenantsWithoutBinding = instanceTenants;
  if (instanceTenants.length > bindingTenants.length) {
    for (let i = 0; i < bindingTenants.length; i++) {
      let instanceTenantIndex = instanceTenantsWithoutBinding.indexOf(bindingTenants[i]);
      if (instanceTenantIndex >= 0) {
        instanceTenantsWithoutBinding.splice(instanceTenantIndex, 1);
      }
    }
  } else {
    instanceTenantsWithoutBinding = instanceTenants.filter(it => !bindingTenants.includes(it));
  }

  return instanceTenantsWithoutBinding;
}



function ErrorInfo(err){
  if (err.responseError !== undefined){
    return err;
  }
  if (typeof err !== 'object'){
    var errorInfo = new Error(err.name);
    errorInfo.responseError = err.name;
    errorInfo.responseStatusCode = err.statusCode;
    errorInfo.responseDescription = err.message;
    return errorInfo;
  }

  err.responseError = err.name;
  err.responseStatusCode = err.statusCode;
  err.responseDescription = err.message;
  return err;
}

