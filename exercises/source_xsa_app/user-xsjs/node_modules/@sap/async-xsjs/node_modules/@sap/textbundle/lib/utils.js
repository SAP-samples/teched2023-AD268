'use strict';

var assert = require('assert');
var nodeUtils = require('util');

/**
 * Pattern to analyze MessageFormat strings.
 *
 * Group 1: captures doubled single quotes within the string
 * Group 2: captures quoted fragments within the string.
 *            Note that java.util.MessageFormat silently forgives a missing single quote at
 *            the end of a pattern. This special case is handled by the RegEx as well.
 * Group 3: captures placeholders
 *            Checks only for numerical argument index, any remainder is ignored up to the next
 *            closing curly brace. Nested placeholdes are not accepted!
 * Group 4: captures any remaining curly braces and indicates syntax errors
 *
 *                    [-1] [----- quoted string -----] [------ placeholder ------] [--]
 * @private
 */
var messageFormatRegEx = /('')|'([^']+(?:''[^']*)*)(?:'|$)|\{([0-9]+(?:\s*,[^{}]*)?)\}|[{}]/g;

function formatMessage(pattern, values) {
    assert(typeof pattern === 'string' || pattern instanceof String, 'Pattern must be string.');
    if (arguments.length > 2 || (values !== null && !nodeUtils.isArray(values))) {
        values = Array.prototype.slice.call(arguments, 1);
    }
    values = values || [];
    return pattern.replace(messageFormatRegEx, function ($0, $1, $2, $3, offset) {
        if ($1) {
            // a doubled single quote in a normal string fragment
            //   --> emit a single quote
            return "'"; // eslint-disable-line quotes
        }
        else if ($2) {
            // a quoted sequence of chars, potentially containing doubled single quotes again
            //   --> emit with doubled single quotes replaced by a single quote
            return $2.replace(/''/g, "'"); // eslint-disable-line quotes
        }
        else if ($3) {
            // a welformed curly brace
            //   --> emit the argument but ignore other parameters
            return String(values[parseInt($3, 10)]);
        }
        // e.g. malformed curly braces
        //   --> throw Error
        throw new Error('formatMessage: pattern syntax error at pos. ' + offset);
    });
}
module.exports.formatMessage = formatMessage;


/**
 * Resource bundles are stored according to the Java Development Kit conventions.
 * JDK uses old language names fora few ISO639 codes ("iw" for"he", "ji" for"yi", "in" for"id" and "sh" for"sr").
 * Make sure to convert newer codes to older ones before creating file names.
 * @private
 */
var M_ISO639_NEW_TO_OLD = {
    he: 'iw',
    yi: 'ji',
    id: 'in',
    sr: 'sh'
};

var SAPSupportabilityLocales = /-(saptrc|sappsd)(?:-|$)/i;

/**
 * Helper to normalize the given locale (in BCP-47 syntax) to the java.util.Locale format.
 * @param {string} locale locale to normalize
 * @return {string} Normalized locale or undefined if the locale can't be normalized
 *
 * [---------- language ----------][----- script -----][------ region -----][----- variants -----][----- extensions -----][----- private use -----]
 * @private
 */
var localeRegEx = /^((?:[A-Z]{2,3}(?:-[A-Z]{3}){0,3})|[A-Z]{4}|[A-Z]{5,8})(?:-([A-Z]{4}))?(?:-([A-Z]{2}|[0-9]{3}))?(-[0-9A-Z]{5,8}|(?:[0-9][0-9A-Z]{3}))*(?:-([0-9A-WYZ](?:-[0-9A-Z]{2,8})+))*(?:-(X(?:-[0-9A-Z]{1,8})+))?$/i;

function normalize(locale) {
    var match, sLanguage, sScript, sRegion, sVariants, sPrivate;
    if (typeof locale === 'string' && (match = localeRegEx.exec(locale.replace(/_/g, '-')))) {
        sLanguage = match[1].toLowerCase();
        sLanguage = M_ISO639_NEW_TO_OLD[sLanguage] || sLanguage;
        sScript = match[2] ? match[2].toLowerCase() : undefined;
        sRegion = match[3] ? match[3].toUpperCase() : undefined;
        sVariants = match[4];
        sPrivate = match[6];
        // recognize and convert special SAP supportability locales (overwrites match[]]!)
        if ((sPrivate && (match = SAPSupportabilityLocales.exec(sPrivate))) || (sVariants && (match = SAPSupportabilityLocales.exec(sVariants)))) {
            return 'en_US_' + match[1].toLowerCase(); // for now enforce en_US (agreed with SAP SLS)
        }
        // Chinese: when no region but a script is specified, use default region foreach script
        if (sLanguage === 'zh' && !sRegion) {
            if (sScript === 'hans') {
                sRegion = 'CN';
            }
            else if (sScript === 'hant') {
                sRegion = 'TW';
            }
        }
        return sLanguage + (sRegion ? '_' + sRegion + (sVariants ? '_' + sVariants.slice(1).replace('-', '_') : '') : '');
    }
    return '';
}
module.exports.normalize = normalize;

function callerLocation(skip) {
    var e = {},
        p = Error.prepareStackTrace;
    Error.prepareStackTrace = function (_, s) {
        return s;
    };
    Error.captureStackTrace(e, callerLocation);
    var cs = e.stack[skip || 0];
    Error.prepareStackTrace = p;
    return cs.getFileName();
}
module.exports.callerLocation = callerLocation;
