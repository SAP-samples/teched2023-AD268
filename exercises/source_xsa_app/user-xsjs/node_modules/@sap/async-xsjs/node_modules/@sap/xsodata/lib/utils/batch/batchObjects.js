'use strict';


var generatedKey = require('./../keyGenerator');
var NotSupported = require('./../errors/http/notSupported');
exports.Batch = Batch;
function Batch(type) {
    this.type = type;
    this.isChangeSet = (type === 'changeset');
    if (this.isChangeSet) {
        this.changeSetErrorResponse = null;
    }
    this.parts = [];
}

Batch.prototype.write = function (context, response) {
    if (this.changeSetErrorResponse) {
        //if an error in the changeset occured then only the response of this error is returned
        response.statusCode = 200;//TODO check responce
        response.write('Content-Type: application/http\r\n');
        response.write('Content-Transfer-Encoding: binary\r\n');
        response.write('\r\n'); //end of header

        this.changeSetErrorResponse.writeToBatchResponse(response);
    } else {
        response.statusCode = 200;
        var boundary = 'batch_' + generatedKey.createBoundary(context);
        if (this.isChangeSet) {
            response.write('Content-Type: multipart/mixed; boundary=' + boundary + '\r\n');
            response.write('\r\n'); //end of header
        } else {
            response.setHeader('Content-Type', 'multipart/mixed; boundary=' + boundary);
        }

        response.write('--' + boundary + '\r\n');
        for (var i = 0; i < this.parts.length; i++) {
            if (i !== 0) {
                response.write('\r\n--' + boundary + '\r\n');
            }
            this.parts[i].write(context, response);
        }
        response.write('\r\n--' + boundary + '--\r\n');
    }
};


/**
 * @param {Object} headers
 * @param {Object} content
 * @constructor
 */
function BatchPart(headers, content) {
    this.type = "part";
    this.headers = headers;
    this.content = content;
}
BatchPart.prototype.write = function (context, response) {
    this.content.write(context, response);
};

/**
 * @param {String} url
 * @param {Object} headers
 * @param {Array} payload
 * @constructor
 */
exports.AppHttp = function (url, headers, payload) {
    this.type = "app";
    this.rawData = {
        url: url,
        headers: headers,
        payload: payload
    };

    this.contentId = undefined;
    this.request = undefined;
    this.response = undefined;
};

exports.AppHttp.prototype.write = function (context, response) {
    response.write('Content-Type: application/http\r\n');
    response.write('Content-Transfer-Encoding: binary\r\n');
    response.write('\r\n'); //end of header

    this.response.writeToBatchResponse(response, this.contentId);
};


exports.BatchContent = BatchContent;


function split(input) {
    var LF = '\n';
    var CRLF = '\r\n';
    var a = [];

    var pL = 0;
    var p1 = input.indexOf(CRLF, pL);
    var p2 = input.indexOf(LF, pL);

    while (p1 !== -1 || p2 !== -1) {
        if (p1 !== -1 && p1 <= p2) {
            a.push(input.substring(pL, p1));
            pL = p1 + 2;
        } else {
            a.push(input.substring(pL, p2));
            pL = p2 + 1;
        }
        p1 = input.indexOf(CRLF, pL);
        p2 = input.indexOf(LF, pL);
    }
    if (pL < input.length) {
        a.push(input.substring(pL));
    }
    return a;
}

function BatchContent(data) {
    if (typeof data === 'string') {
        this.type = 0;
        this.stringData = data;
        this.stringSplit = split(data);
        this.pos = 0;
    } else {
        throw new NotSupported('Only string allowed for batch parser');
    }
}

BatchContent.prototype.lookLine = function () {
    return this.stringSplit[this.pos];
};

BatchContent.prototype.readLine = function () {
    return this.stringSplit[this.pos++];
};

BatchContent.prototype.inc = function () {
    this.pos++;
};
