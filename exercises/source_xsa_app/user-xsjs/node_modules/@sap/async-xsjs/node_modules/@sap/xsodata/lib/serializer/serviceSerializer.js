'use strict';

var XMLWriter = require('xml-writer');
var jsonSerializer = require('./../serializer/jsonSerializer');
var types = require('./../utils/checkContentType');
var contentTypeTools = require('./../utils/checkContentType');
var NotAcceptable = require('./../utils/errors/http/notAcceptable');

var Measurement = require('./../utils/measurement');


function writeXML(request, response, context) {
    var writer = function writer(string) {
        response.write(string);
    };

    var xw = new XMLWriter(true, writer);//change to false for unformatted output
    xw.startDocument('1.0', 'utf-8', true);
    xw.startElement('service');

    xw.writeAttribute('xml:base', context.uriTree.baseUrl);
    xw.writeAttribute('xmlns:atom', 'http://www.w3.org/2005/Atom');
    xw.writeAttribute('xmlns:app', 'http://www.w3.org/2007/app');
    xw.writeAttribute('xmlns', 'http://www.w3.org/2007/app');
    xw.startElement('workspace');

    xw.startElement('atom:title');
    xw.text('Default');
    xw.endElement();

    var entityTypes = context.gModel.getEntityTypes();
    for (var name in entityTypes) {
        if (entityTypes.hasOwnProperty(name)) {
            var entityType = entityTypes[name];
            xw.startElement('collection');
            xw.writeAttribute('href', entityType.name);
            xw.startElement('atom:title');
            xw.text(entityType.name);
            xw.endElement();
            xw.endElement();
        }
    }

    xw.endDocument();
    response.write(xw.toString());
}

function writeJSON(request, response, context) {
    var serializer = new jsonSerializer.JsonSerializer(context, 65536);

    var entityTypes = context.gModel.getEntityTypes();
    var d = {'EntitySets': []};

    for (var name in entityTypes) {
        if (entityTypes.hasOwnProperty(name)) {
            var entityType = entityTypes[name];
            d.EntitySets.push(entityType.name);
        }
    }

    serializer.write({d: d});
    serializer.flush();
}

exports.process = function (context, asyncDone) {
    var method = context.request.method;

    switch (method) {
        case "HEAD":
            return processHEAD(context, asyncDone);
        default:
            return processGET(context, asyncDone);
    }
};

function processHEAD(context, asyncDone) {
    context.response.writeHead(200);
    return asyncDone(null, context);
}



function processGET(context, asyncDone) {
    var request, response, format;
    context.logger.silly('serviceprocessor', 'process');

    request = context.request;
    response = context.response;

    format = context.oData.systemQueryParameters.format;
    context.payloadType = Measurement.measureSync(contentTypeTools.checkServiceDocument, context.request, format, 'contentTypeTools.checkServiceDocument');
    response.writeHead(200, {'Content-Type': context.payloadType + ';charset=utf-8'});
    context.responseHeadSet = true;

    if (context.payloadType === types.cTypes.ctJson) {
        Measurement.measureSync(writeJSON, request, response, context, 'writeJSON');
    } else {
        //should process this only if custom header format is used and set to 'atomXml'
        if (!(context.uriTree.queryParameters && context.uriTree.queryParameters.format==='atomXml')) {
            throw new NotAcceptable('Format ' + context.payloadType + ' not supported.');
        }
        Measurement.measureSync(writeXML, request, response, context, 'writeXML');
    }

    return asyncDone(null, context);
}
