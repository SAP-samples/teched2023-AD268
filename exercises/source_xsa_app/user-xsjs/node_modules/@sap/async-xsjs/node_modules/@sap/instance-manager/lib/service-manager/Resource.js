'use strict';

var fetch = require('node-fetch');
var debug = require('debug')('instance-manager');
var https = require('https');

var HTTP = require('./constants').STATUS.HTTP;
var safeParse = require('../utils').safeJsonParse;
var isNonEmptyString = require('../utils').isNonEmptyString;
var urlAppendQueryString = require('../utils').urlAppendQueryString;
var processSmErrorsPropertyValue = require('./utils').processSmErrorsPropertyValue;

var DEBUG_SEPARATOR = ' - ';

module.exports = Resource;

function Resource(options, tokenHandler, resourceType) {
  this._supportedApi = 'v1';
  this._options = options;
  this._tokenHandler = tokenHandler;
  this._resourceType = resourceType;
}

Resource.prototype.getType = function () {
  return this._resourceType;
};

Resource.prototype.create = function (body, cb) {
  this._triggerAsyncOperation({
    method: 'POST',
    uri: this._buildPath(),
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(body)
  }, cb);
};

Resource.prototype.fetch = function (id, cb) {
  this._sendGetRequest({
    uri: this._buildPath(id)
  }, function (err, reqContext, body) {
    if (err) {
      return cb(err);
    }

    reqContext.push('Resource ready: ' + body.ready);
    debug(reqContext.join(DEBUG_SEPARATOR));

    cb(null, body);
  });
};

Resource.prototype.list = function (query, cb) {
  this._fetchItems({
    uri: this._buildPath(),
    qs: Object.assign({}, query)
  }, [], cb);
};

Resource.prototype.delete = function (id, cb) {
  this._triggerAsyncOperation({
    method: 'DELETE',
    uri: this._buildPath(id)
  }, cb);
};

// for async operations we get the full path in the response Location header
// instead of (resource id, operation id) pair
Resource.prototype.getOperation = function (fullPath, cb) {
  this._sendGetRequest({
    uri: fullPath
  }, function (err, reqContext, body) {
    if (err) {
      return cb(err);
    }

    reqContext.push('Operation: ' + body.type + ', state: ' + body.state);

    debug(reqContext.join(DEBUG_SEPARATOR));

    cb(null, body);
  });
};

Resource.prototype._buildPath = function (id) {
  var path = '/' + this._supportedApi + '/' + this._resourceType;
  if (id) {
    path += '/' + id;
  }
  return path;
};

Resource.prototype._triggerAsyncOperation = function (reqOptions, cb) {
  reqOptions.qs = { 'async': true };

  this._sendRequest(reqOptions, function (err, reqContext, res, body) {
    if (err) {
      return cb(err);
    }

    if (res.statusCode !== HTTP.ASYNC_OPERATION_STARTED) {
      return reportUnexpectedStatusError(reqContext, res, body, cb);
    }

    var locationHeader = res.headers.location;
    if (!isNonEmptyString(locationHeader)) {
      return reportError('Location header not available', reqContext, cb);
    }

    reqContext.push('Operation: ' + locationHeader);
    debug(reqContext.join(DEBUG_SEPARATOR));

    cb(null, locationHeader);
  });
};

Resource.prototype._sendGetRequest = function (reqOptions, cb) {
  reqOptions.method = 'GET';
  this._sendRequest(reqOptions, function (err, reqContext, res, body) {
    if (err) {
      return cb(err);
    }

    if (res.statusCode !== HTTP.OK) {
      return reportUnexpectedStatusError(reqContext, res, body, cb);
    }

    var parseResult = safeParse(body);
    if (parseResult.err) {
      return reportError('Could not parse response body: ' + parseResult.err.message, reqContext, cb);
    }

    cb(null, reqContext, parseResult.data);
  });
};

Resource.prototype._fetchItems = function (reqOptions, arr, cb) {
  var self = this;
  this._sendGetRequest(reqOptions, function (err, reqContext, body) {
    if (err) {
      return cb(err);
    }

    arr = arr.concat(body.items);

    debug(reqContext.concat(['Accumulated items: ' + arr.length]).join(DEBUG_SEPARATOR));

    var pageToken = body.token;
    if (!pageToken) {
      return cb(null, arr);
    }

    reqOptions.qs.token = pageToken;
    self._fetchItems(reqOptions, arr, cb);
  });
};

Resource.prototype._sendRequest = function (reqOptions, cb) {
  var self = this;
  reqOptions.baseUrl = this._options.sm_url;
  var reqContext = [reqOptions.method, reqOptions.uri];
  reqOptions.qs && reqContext.push('Query: ' + JSON.stringify(reqOptions.qs));

  this._tokenHandler.getToken(function (err, token) {
    if (err) {
      return reportError('Could not fetch access token error: ' + err.message, reqContext, cb);
    }

    var res = {
      headers: {}
    };
    var url = reqOptions.baseUrl + reqOptions.uri;
    url = urlAppendQueryString(url, reqOptions.qs);
    var headers = reqOptions.headers || {};
    headers['Authorization'] = 'Bearer ' + token;

    let agent = null;
    if (self._options && self._options.certificate) {
      const httpsAgent = new https.Agent({
        certificate: self._options.certificate,
        key: self._options.key
      });
      agent = httpsAgent;
    }

    fetch(url, {
      method: reqOptions.method,
      headers: headers,
      body: reqOptions.body,
      agent: agent
    }).then(function (response) {
      res.statusCode = response.status;
      for (var header of response.headers) {
        res.headers[header[0].toLowerCase()] = header[1];
      }
      return response.text();
    }).then(function (body) {
      reqContext.push('Response status ' + res.statusCode);
      cb(null, reqContext, res, body);
    }).catch(function (err) {
      reportError('Error: ' + err.message, reqContext, cb);
    });
  });
};

function reportError(message, reqContext, cb) {
  reqContext.push(message);
  message = reqContext.join(DEBUG_SEPARATOR);

  debug(message);
  cb(new Error(message));
}

function reportUnexpectedStatusError(reqContext, res, body, cb) {
  var reason = errorReason(res, body);
  reason && reqContext.push(reason);
  var message = reqContext.join(DEBUG_SEPARATOR);

  debug(message);
  var err = new Error(message);
  err.statusCode = res.statusCode;
  cb(err);
}

function errorReason(res, body) {
  if (!body) {
    return;
  }

  var contentType = res.headers['content-type'];
  if (contentType && contentType.indexOf('application/json') === 0) {
    var parseResult = safeParse(body);
    if (parseResult.data) {
      var data = parseResult.data;

      return processSmErrorsPropertyValue(data.errors || data);
    }
  }

  return body;
}
