/* Parses and OData 2.0 $filter expression */


/* first token match wins , use %options flex to use longest match*/

/***** start lexer ****/

%lex

/***** definitions ****/

DIG         [0-9]
H			[a-fA-F0-9]
QUOTE       \'

%%

/***** rules **********/

\s+                   /* whitespaces*/

null                  return 'nulll'
true                  return 'true'
false                 return 'false'
{DIG}+"."{DIG}+("E"|"e")("-"|"+")?{DIG}+("F"|"f"|"D"|"d"|"M"|"m"|"L"|"l")   return 'digits4'
{DIG}+"."{DIG}+("F"|"f"|"D"|"d"|"M"|"m"|"L"|"l")                  return 'digits3'
{DIG}+("F"|"f"|"D"|"d"|"M"|"m"|"L"|"l")                           return 'digits2'
{DIG}+                                                            return 'digits1'


/*edm types*/
("X"|"binary"){QUOTE}({H}{H})*{QUOTE}
    return 'binary';

"guid"{QUOTE}{H}{H}{H}{H}{H}{H}{H}{H}"-"{H}{H}{H}{H}"-"{H}{H}{H}{H}"-"{H}{H}{H}{H}{H}{H}{H}{H}{H}{H}{H}{H}{QUOTE}
    return 'guid';

"datetime"{QUOTE}{DIG}{DIG}{DIG}{DIG}"-"{DIG}{DIG}?"-"{DIG}{DIG}?"T"{DIG}{DIG}?":"{DIG}{DIG}(":"{DIG}{DIG}("."{DIG}+)?)?{QUOTE}
    return 'datetime';

"time"{QUOTE}"PT"({DIG}{DIG}?"H")?({DIG}{DIG}?"M")?({DIG}?{DIG}?("."{DIG}+)?"S")?{QUOTE}
    return 'time';

/*operators*/
"add"   return 'add'
"sub"   return 'sub'
"mul"   return 'mul'
"div"   return 'div'
"mod"   return 'mod'
"not"   return 'not'
"and"   return 'and'
"or"   return 'or'
"eq"   return 'eq'
"ne"   return 'ne'
"lt"   return 'lt'
"gt"   return 'gt'
"le"   return 'le'
"ge"   return 'ge'


/*methods*/
"startswith"            return 'startswith'
"endswith"              return 'endswith'
"substring"             return 'substring'
"substringof"           return 'substringof'
"indexof"               return 'indexof'
"replace"               return 'replace'
"tolower"               return 'tolower'
"toupper"               return 'toupper'
"trim"                  return 'trim'
"concat"                return 'concat'
"length"                return 'length'
"year"                  return 'year'
"month"                 return 'month'
"day"                   return 'day'
"hour"                  return 'hour'
"minute"                return 'minute'
"second"                return 'second'
"round"                 return 'round'
"ceiling"               return 'ceiling'
"floor"                 return 'floor'

"+"    return '+'
"-"    return '-'
"/"    return '/'
"("    return '('
")"    return ')'
"."    return ".";
","    return ",";




\'([^\']|\'\')*\'       return 'string';

/* According to Odata CSDL Spec, hyphens and points are not allowed for OData Indentifiers.
However, in XS Classic hyphen's and points are allowed. Hence, due to compatibility with XSC XSOData services,
we also allow hyphens and points. E.g. for property names.
Service developers must be aware, that services using hyphens and points may not be compatible with each client. */

[a-zA-Z]([a-zA-Z0-9_\-\.])*  return 'property';

/* don't parse garbage at filters end */
<<EOF>>                 return 'EOF'
/lex


/***** precedence *****/

/* operator associations and precedence, low to high */
%left or
%left and
%left eq ne
%left ge le gt lt
%left add sub
%left mul div mod
%left UNEGATE    /* for unary "-" */
%left UNOT      /* for unary "not*/
%left '/'


/***** start expressions ******/

%start expressions

%% /* language grammar */

number
    :   digits1
        {$$ = new edm.Number($1);}
    |   digits2
        {$$ = new edm.Number($1);}
    |   digits3
        {$$ = new edm.Number($1);}
    |   digits4
        {$$ = new edm.Number($1);}
    ;

methods
    :   startswith '(' ce ',' ce ')'
        {$$ = new edm.Method(edm.STARTSWITH,[$3,$5]);}
    |   endswith '(' ce ',' ce ')'
        {$$ = new edm.Method(edm.ENDSWITH,[$3,$5]);}
    |   substring '(' ce ',' ce ')'
        {$$ = new edm.Method(edm.SUBSTRING,[$3,$5]);}
    |   substring '(' ce ',' ce ',' ce ')'
        {$$ = new edm.Method(edm.SUBSTRING,[$3,$5,$7]);}
    |   substringof '(' ce ',' ce ')'
        {$$ = new edm.Method(edm.SUBSTRINGOF,[$3,$5]);}
    |   indexof '(' ce ',' ce ')'
        {$$ = new edm.Method(edm.INDEXOF,[$3,$5]);}
    |   replace '(' ce ',' ce ',' ce ')'
        {$$ = new edm.Method(edm.REPLACE,[$3,$5,$7]);}
    |   tolower '(' ce ')'
        {$$ = new edm.Method(edm.TOLOWER,[$3]);}
    |   toupper '(' ce  ')'
        {$$ = new edm.Method(edm.TOUPPER,[$3]);}
    |   trim '(' ce ')'
        {$$ = new edm.Method(edm.TRIM,[$3]);}
    |   concat '(' ce ',' ce ')'
        {$$ = new edm.Method(edm.CONCAT,[$3,$5]);}
    |   length '(' ce ')'
        {$$ = new edm.Method(edm.LENGTH,[$3]);}
    |   year '(' ce  ')'
        {$$ = new edm.Method(edm.YEAR,[$3]);}
    |   month '(' ce  ')'
        {$$ = new edm.Method(edm.MONTH,[$3]);}
    |   day '(' ce  ')'
        {$$ = new edm.Method(edm.DAY,[$3]);}
    |   hour '(' ce  ')'
        {$$ = new edm.Method(edm.HOUR,[$3]);}
    |   minute '(' ce ')'
        {$$ = new edm.Method(edm.MINUTE,[$3]);}
    |   second '(' ce  ')'
        {$$ = new edm.Method(edm.SECOND,[$3]);}
    |   round '(' ce  ')'
        {$$ = new edm.Method(edm.ROUND,[$3]);}
    |   ceiling '(' ce ')'
        {$$ = new edm.Method(edm.CEILING,[$3]);}
    |   floor '(' ce  ')'
        {$$ = new edm.Method(edm.FLOOR,[$3]);}
    ;

literal
    :   nulll
        {$$ = new edm.Null();}
    |   true
        {$$ = new edm.Boolean(true);}
    |   false
        {$$ = new edm.Boolean(false);}
    |   number
        {$$ = $1;}
    |   binary
        {$$ = new edm.Binary($1);}
    |   guid
        {$$ = new edm.Guid($1);}
    |   datetime
        {$$ = new edm.DateTime($1);}
    |   time
        {$$ = new edm.Time($1);}
    |   string
        {$$ = new edm.EdmString($1);}
    ;

ce  :
    ce 'or' ce
        {$$ = new edm.BinaryOperator(edm.OR,$1,$3);}
    | ce 'and' ce
        {$$ = new edm.BinaryOperator(edm.AND,$1,$3);}
    |ce 'eq' ce
        {$$ = new edm.BinaryOperator(edm.EQ,$1,$3);}
    | ce 'ne' ce
        {$$ = new edm.BinaryOperator(edm.NE,$1,$3);}
    | ce 'ge' ce
        {$$ = new edm.BinaryOperator(edm.GE,$1,$3);}
    | ce 'le' ce
        {$$ = new edm.BinaryOperator(edm.LE,$1,$3);}
    | ce 'gt' ce
        {$$ = new edm.BinaryOperator(edm.GT,$1,$3);}
    | ce 'lt' ce
        {$$ = new edm.BinaryOperator(edm.LT,$1,$3);}
    | ce 'add' ce
        {$$ = new edm.BinaryOperator(edm.ADD,$1,$3);}
    | ce 'sub' ce
        {$$ = new edm.BinaryOperator(edm.SUB,$1,$3);}
    | ce 'mul' ce
        {$$ = new edm.BinaryOperator(edm.MUL,$1,$3);}
    | ce 'div' ce
        {$$ = new edm.BinaryOperator(edm.DIV,$1,$3);}
    | ce 'mod' ce
        {$$ = new edm.BinaryOperator(edm.MOD,$1,$3);}
    | 'not' ce %prec UNOT
        {$$ = new edm.UnaryOperator(edm.NOT,$2);}
    | '-' ce %prec UNEGATE
        {
            if ( $2 instanceof edm.Number) {
                $2.sign = $2.sign * -1;
                $$ = $2;
            } else {
                $$ = new edm.UnaryOperator(edm.NEGATE,$2);
            }
        }
    | '(' ce ')'
        {$$ = new edm.Parenthesis($2);}
    | ce '/' ce
        {$$ = new edm.Member($1,$3);}
    | methods
        {$$ = $1; }
    | property
        {$$ = new edm.Property($1);}
    | literal
        {$$ = $1;}
    ;

expressions
    : ce EOF
        {return $1;}
    ;
%%

var edm = require('./../utils/typedObjects');

