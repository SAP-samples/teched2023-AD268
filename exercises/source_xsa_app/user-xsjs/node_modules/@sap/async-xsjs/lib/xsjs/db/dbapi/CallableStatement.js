'use strict';

var _ = require('lodash');
var util = require('util');
var Statement = require('./Statement');
var conversions = require('./conversions');

module.exports = CallableStatement;

util.inherits(CallableStatement, Statement);

function CallableStatement(statement) {
  Statement.call(this, statement);
}

/**
 * Returns an integer value of a TINYINT, SMALLINT, INT or BIGINT parameter types
 * An exception will be thrown if the value is bigger than 9007199254740992 (2^53) or smaller than -9007199254740992 (-2^53).
 * @param {integer} index The index of the parameter <b>starting from 1</b>
 * @returns {integer} Integer representation
 * @throws Throws an error if the index parameter is not valid or the SQL type of the queried parameter does not match.
 */
CallableStatement.prototype.getInteger = function (columnIndex) {
  return conversions.getInteger(getValue.call(this, columnIndex));
};

CallableStatement.prototype.getInt = CallableStatement.prototype.getInteger;

/**
 * Returns an Int64 value of a BIGINT parameter
 * @param {integer} index The index of the parameter <b>starting from 1</b>
 * @returns {ctypes.Int64} ctypes.Int64
 * @throws Throws an error if the index parameter is not valid or the SQL type of the queried parameter does not match.
 */
CallableStatement.prototype.getBigInt = function (columnIndex) {
  return conversions.getBigInt(getValue.call(this, columnIndex));
};

/**
 * Returns a string value of a CHAR or VARCHAR parameter; ASCII only, not suitable for strings containing unicode characters.
 * @param {integer} index The index of the parameter <b>starting from 1</b>
 * @returns {string} String representation
 * @throws Throws an error if the index parameter is not valid or the SQL type of the queried parameter does not match.
 */
CallableStatement.prototype.getString = function (columnIndex) {
  return conversions.getString(getValue.call(this, columnIndex),
  this._parameterInfo[columnIndex - 1].nativeType);
};

/**
 * Returns the string value of an NCHAR, an NVARCHAR, or a SHORTTEXT parameter
 * @param {integer} index The index of the parameter <b>starting from 1</b>
 * @returns {string} String representation
 * @throws Throws an error if the index parameter is not valid or the SQL type of the queried parameter does not match.
 */
CallableStatement.prototype.getNString = CallableStatement.prototype.getString;

/**
 * Returns a number value of a DECIMAL parameter
 * @param {integer} index The index of the parameter <b>starting from 1</b>
 * @returns {number} Number representation
 * @throws Throws an error if the index parameter is not valid or the SQL type of the queried parameter does not match.
 */
CallableStatement.prototype.getDecimal = function (columnIndex) {
  return conversions.getDecimal(getValue.call(this, columnIndex));
};

/**
 * Returns a number value of the specified column. getReal is used for REAL column types.
 * @param {integer} columnIndex The target column <b>starting from 1</b>
 * @returns {number} Number representation
 * @throws Throws an error if the index parameter is not valid.
 */
CallableStatement.prototype.getReal = CallableStatement.prototype.getDecimal;

/**
 * Returns a number value of the specified column. getFloat is used for FLOAT column types.
 * @param {integer} columnIndex The target column <b>starting from 1</b>
 * @returns {number} Number representation
 * @throws Throws an error if the index parameter is not valid.
 */
CallableStatement.prototype.getFloat = CallableStatement.prototype.getDecimal;

/**
 * Returns a number value of a DOUBLE, FLOAT or REAL parameter
 * @param {integer} index The index of the parameter <b>starting from 1</b>
 * @returns {number} Number representation
 * @throws Throws an error if the index parameter is not valid or the SQL type of the queried parameter does not match.
 */
CallableStatement.prototype.getDouble = CallableStatement.prototype.getDecimal;

/**
 * Returns the ArrayBuffer value of a BLOB specified parameter
 * @param {integer} index The index of the parameter <b>starting from 1</b>
 * @returns {ArrayBuffer} Blob representation
 * @throws Throws an error if the index parameter is not valid or the SQL type of the queried parameter does not match.
 */
CallableStatement.prototype.getBlob = function (columnIndex) {
  return conversions.getBlob(getValue.call(this, columnIndex),
    this._parameterInfo[columnIndex - 1].nativeType);
};

/**
 * Returns an ArrayBuffer object of the specified column. getBString is used for BINARY and VARBINARY column types.
 * @param {integer} index The index of the parameter <b>starting from 1</b>
 * @returns {ArrayBuffer} value ArrayBuffer object
 * @throws Throws an error if the index parameter is not valid or the SQL type of the queried parameter does not match.
 */
CallableStatement.prototype.getBString = CallableStatement.prototype.getBlob;

/**
 * Returns the string value of a CLOB parameter
 * @param {integer} index The index of the parameter <b>starting from 1</b>
 * @returns {string} String representation
 * @throws Throws an error if the index parameter is not valid or the SQL type of the queried parameter does not match.
 */
CallableStatement.prototype.getClob = function (columnIndex) {
  return conversions.getClob(getValue.call(this, columnIndex),
    this._parameterInfo[columnIndex - 1].nativeType);
};


/**
 * Returns the string value of a NCLOB or TEXT parameter
 * @param {integer} index The index of the parameter <b>starting from 1</b>
 * @returns {string} String representation
 * @throws Throws an error if the index parameter is not valid or the SQL type of the queried parameter does not match.
 */
CallableStatement.prototype.getNClob = CallableStatement.prototype.getClob;

/**
 * Returns the string value of a TEXT parameter
 * @param {integer} index The index of the parameter <b>starting from 1</b>
 * @returns {string} String representation
 * @throws Throws an error if the index parameter is not valid or the SQL type of the queried parameter does not match.
 */
CallableStatement.prototype.getText = CallableStatement.prototype.getClob;

/**
 * Used to retrieve the value of a DATE parameter
 * @param {integer} index The index of the parameter, <b>starting from 1</b>
 * @returns {Date} A JavaScript date object representing the value
 * @throws Throws an error if the index parameter is not valid or the SQL type of the queried parameter does not match.
 */
CallableStatement.prototype.getDate = function (columnIndex) {
  return conversions.getDate(getValue.call(this, columnIndex));
};


/**
 * Used to retrieve the value of a TIME parameter
 * @param {integer} index The index of the parameter <b>starting from 1</b>
 * @returns {Date} A JavaScript date object representing the value
 * @throws Throws an error if the index parameter is not valid or the SQL type of the queried parameter does not match.
 */
CallableStatement.prototype.getTime = function (columnIndex) {
  return conversions.getTime(getValue.call(this, columnIndex));
};

/**
 * Used to retrieve the value of a SECONDDATE parameter
 * @param {integer} index The index of the parameter <b>starting from 1</b>
 * @returns {Date} A JavaScript date object representing the value
 * @throws Throws an error if the index parameter is not valid or the SQL type of the queried parameter does not match.
 */
CallableStatement.prototype.getSeconddate = CallableStatement.prototype.getDate;

/**
 * Used to retrieve the value of a TIMESTAMP parameter. <br>
 * As this type contains only time information and no date, the JavaScript's date object will always be 1 Jan 1970 plus the time offset.<br>
 * For example: if the stored value is 10:00:00, the JavaScript date object will specify: 1 Jan 1970 10:00:00
 *
 * @param {integer} index The index of the parameter <b>starting from 1</b>
 * @returns {Date} A JavaScript date object representing the value
 * @throws Throws an error if the index parameter is not valid or the SQL type of the queried parameter does not match.
 */
CallableStatement.prototype.getTimestamp = CallableStatement.prototype.getDate;

function getValue(columnIndex) {
  if (!this._results) {
    throw new Error('Callable statement not executed');
  }
  if (!_.isNumber(columnIndex)) {
    throw new Error('Index should be a number');
  }
  const paramLength = this._results.parameters.length;
  if (columnIndex < 1 || columnIndex > paramLength) {
    throw new Error(`Index should be within 1 - ${paramLength}`);
  }
  return this._results.parameters[columnIndex - 1];
}

