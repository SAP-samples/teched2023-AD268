'use strict';

var assert = require('assert');
var connection = require('../db/common/connection');
var dbStream = require('@sap/hana-client/extension/Stream');

exports.createStore = createStore;

function createStore(dbReqOptions) {
  var openConnections = new Set();

  var storeConstructor = function (secureStoreFile) {
    return dbReqOptions.getInstanceOptionsPromise()
      .then((hanaOptions) => {
        return connection.connect(hanaOptions);
      })
      .then((client) => {
        openConnections.add(client);
        return new Store(client, secureStoreFile);
      });
  };

  storeConstructor._closeAllConnections = function () {
    for (var client of openConnections) {
      client.close(function () { }); // ignoring an error here;
    }
    openConnections.clear();
  };

  return storeConstructor;
}

function Store(client, secureStoreFile) {
  this._client = client;
  this._secureStoreFile = secureStoreFile;
}

Store.prototype.read = async function (parameter) {
  checkParameterHasName(parameter, 'read');
  return await read.call(this, parameter, false);
};

Store.prototype.readForUser = async function (parameter) {
  checkParameterHasName(parameter, 'readForUser');
  return await read.call(this, parameter, true);
};

async function read(parameter, isForUser) {
  var result = await callProc(this._client, 'CALL "SYS"."USER_SECURESTORE_RETRIEVE"(?, ?, ?, ?)', {
    STORE_NAME: this._secureStoreFile,
    FOR_XS_APPLICATIONUSER: isForUser,
    KEY: parameter.name
  });
  return result && result.VALUE ? result.VALUE.toString('utf8') : null;
}

Store.prototype.remove = async function (parameter) {
  checkParameterHasName(parameter, 'remove');
  await remove.call(this, parameter, false);
};

Store.prototype.removeForUser = async function (parameter) {
  checkParameterHasName(parameter, 'removeForUser');
  await remove.call(this, parameter, true);
};

async function remove(parameter, isForUser) {
  await callProc(this._client, 'CALL "SYS"."USER_SECURESTORE_DELETE"(?, ?, ?)', {
    STORE_NAME: this._secureStoreFile,
    FOR_XS_APPLICATIONUSER: isForUser,
    KEY: parameter.name
  });
}

Store.prototype.store = async function (parameter) {
  checkWriteParameter(parameter, 'store');
  await store.call(this, parameter, false);
};

Store.prototype.storeForUser = async function (parameter) {
  checkWriteParameter(parameter, 'storeForUser');
  await store.call(this, parameter, true);
};

async function store(parameter, isForUser) {
  await callProc(this._client, 'CALL "SYS"."USER_SECURESTORE_INSERT"(?, ?, ?, ?)', {
    STORE_NAME: this._secureStoreFile,
    FOR_XS_APPLICATIONUSER: isForUser,
    KEY: parameter.name,
    VALUE: Buffer.from(parameter.value, 'utf8')
  });
}

function checkWriteParameter(parameter, functionName) {
  checkParameterHasName(parameter, functionName);
  assert(typeof parameter.value === 'string', 'Store.' + functionName + ' should be called with object containing property value - string!');
}

function checkParameterHasName(parameter, functionName) {
  assert(parameter && typeof parameter === 'object', 'Store.' + functionName + ' called with invalid parameter');
  assert(parameter.name && typeof parameter.name === 'string', 'Store.' + functionName + ' should be called with object containing property name - non empty string!');
}

function callProc(client, sql, params) {
  var stmt = dbStream.createProcStatement(client, sql);
  return new Promise((resolve, reject) => {
    stmt.exec(params, function(){
      var err = arguments[0];
      if (err) {
        stmt.drop();
        reject(err);
      }
      else {
        stmt.drop();
        resolve(arguments[1]);
      }
    });
  });
}