'use strict';

var path = require('path');
var util = require('util');
var utils = require('../../utils');
var jobsClient = require('@sap/jobs-client');

var Schedules = require('./Schedules');
var Schedule = require('./Schedule');

module.exports = Job;

function Job(runtime, constructJob) {
  var self = this;
  this._scheduler = createScheduler(runtime);

  this.schedules = {};
  if (!constructJob.uri) {
    throw new Error('Job: uri string parameter required');
  }
  var jobPath = resolveJobURI(runtime, constructJob.uri);
  var jobName = runtime.getJobName(jobPath);
  return new Promise ((resolve, reject) => {
    self._scheduler.fetchJob({ name: jobName, displaySchedules: true }, function(err, job) {
      if (err) { return reject(err);}
      if (!job._id) {
        reject('Scheduler response missing _id property');
      }
      if (!job.schedules) {
        reject('Scheduler response missing schedules property');
      }
      self._jobId = job._id;
      self.active = job.active;
      var jobSchedules = job.schedules;
      var id = [];
      var schedulesObject = new Schedules(self._scheduler, self._jobId);
      var schedulePromises = jobSchedules.map((jobSchedule) => {
        if (!jobSchedule.scheduleId) {
          reject('Scheduler response missing scheduleId property');
        }
        var description = jobSchedule.description;
        var data = jobSchedule.data;
        var cron = jobSchedule.cron;
        var active = jobSchedule.active;
        var scheduleId = jobSchedule.scheduleId;
        id.push(jobSchedule.scheduleId);
        return new Schedule(self._scheduler,
            description, data, cron, active, self._jobId, scheduleId);
      });
      Promise.all(schedulePromises).then((resolvedSchedules) => {
        var currentScheduleId;
        for (var k = 0; k < resolvedSchedules.length; k++) {
          var resolvedSchedule = resolvedSchedules[k];
          currentScheduleId = id[k];
          schedulesObject[currentScheduleId] = resolvedSchedule;
        }
        self.schedules = schedulesObject;
        resolve(self);
      });
    });
  });
}

Object.defineProperty(Job.prototype, 'deactivate', {
  enumerable : false,
  value : deactivate
});
Object.defineProperty(Job.prototype, 'activate', {
  enumerable : false,
  value : activate
});
Object.defineProperty(Job.prototype, 'configure', {
  enumerable : false,
  value : configure
});


function resolveJobURI(runtime, uri) {
  if (!/\.xsjob$/.test(uri)) {
    throw new Error('URI ' + uri + ' should reference a xsjob');
  }
  var jobPath;
  if (uri[0] === '/') {
    jobPath = uri;
  } else {
    // uri is relative to calling xsjs
    var callingXsjs = utils.getCallingXsjsRelativePath(runtime.get('rootDirs'));
    var dir = path.dirname(callingXsjs);
    jobPath = path.normalize('/' + dir + '/' + uri).replace(/\\/g, '/');
  }
  if (!(jobPath in runtime.xsjobs)) {
    throw new Error('Could not find job ' + jobPath);
  }
  return jobPath;
}

function createScheduler(runtime) {
  var jobs = runtime.get('jobs');
  return new jobsClient.Scheduler({
    baseURL: jobs.url,
    timeout: jobs.timeout,
    user: jobs.user,
    password: jobs.password
  });
}

async function configure(config) {
  if (typeof config !== 'object') {
    throw new Error('Job.configure: takes exactly one parameter object');
  }
  var user = config.user;
  var password = config.password;
  var status = config.status;
  var startTime = config.start_time;
  var endTime = config.end_time;
  if (!config.hasOwnProperty('user')) {
    throw new Error('Job.configure: user string parameter required');
  }
  if (!config.hasOwnProperty('password')) {
    throw new Error('Job.configure: password string parameter required');
  }
  if (!config.hasOwnProperty('locale')) {
    throw new Error('Job.configure: locale string parameter required');
  }
  if (!config.hasOwnProperty('status')) {
    throw new Error('Job.configure: status boolean parameter required');
  }
  if (!config.hasOwnProperty('start_time')) {
    throw new Error('Job.configure: startTime object parameter required');
  }
  if (!config.hasOwnProperty('end_time')) {
    throw new Error('Job.configure: endTime object parameter required');
  }

  // for now we accept only Date objects until we implement date parsing compatible to XS1
  if (!util.isDate(startTime)) {
    throw new Error('Job.configure: startTime object parameter required');
  }
  if (!util.isDate(endTime)) {
    throw new Error('Job.configure: endTime object parameter required');
  }

  var st = convertTime(startTime, 'startTime');
  var et = convertTime(endTime, 'endTime');

  await updateJobPromise(this._scheduler, {
    jobId: this._jobId,
    job: {
      user: user,
      password: password,
      active: status
    }
  });

  for (var scheduleKey in this.schedules) {
    if (scheduleKey === '_jobId') {
      continue;
    }
    await updateJobSchedulePromise(this._scheduler, {
      jobId: this._jobId,
      scheduleId: scheduleKey,
      schedule: {
        startTime: st,
        endTime: et
      }
    });
  }
}

function convertTime(time, propName) {
  if (time === null) {
    return null;
  }
  if (util.isDate(time)) {
    return {
      date: time.toISOString()
    };
  }
  throw new Error('Job.configure: Invalid ' + propName + ' date');
}

async function _activate(job, credentials, active) {
  if (typeof credentials !== 'object') {
    throw new Error('Only one parameter object is required');
  }
  if (!credentials.user) {
    throw new Error('User string parameter required');
  }

  if (!credentials.password) {
    throw new Error('Password string parameter required');
  }

  await updateJobPromise (job._scheduler, {
    jobId: job._jobId,
    job: {
      user: credentials.user,
      password: credentials.password,
      active: active
    }
  });
}

async function activate(credentials) {
  await _activate(this, credentials, true);
}

async function deactivate(credentials) {
  await _activate(this, credentials, false);
}

function updateJobPromise(scheduler, req) {
  return new Promise ((resolve, reject) => {
    scheduler.updateJob(req, function(err, result) {
      if (err) { return reject(err);}
      resolve(result);
    });
  });
}

function updateJobSchedulePromise(scheduler, req) {
  return new Promise ((resolve, reject) => {
    scheduler.updateJobSchedule(req, function(err, result) {
      if (err) { return reject(err);}
      resolve(result);
    });
  });
}