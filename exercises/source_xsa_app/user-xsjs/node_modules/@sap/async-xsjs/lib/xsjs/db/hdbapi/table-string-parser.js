'use strict';

module.exports = {
  parse: parseTableString,
  adaptForHdbext: adaptForHdbext
};

function parseTableString(str) {
  var regex = /^\s*(?:(?:("(?:[^"]|"")*")|([^"][^\s.]*))\s*\.{1})?\s*(?:("(?:[^"]|"")*")|([^"][^\s.]*))\s*$/;
  var result = regex.exec(str);

  if (result === null) {
    return null;
  }

  return {
    schema: {
      escaped: result[1],
      unescaped: result[2]
    },
    table: {
      escaped: result[3],
      unescaped: result[4]
    }
  };
}

function adaptForHdbext(parsed) {
  var adapted = {};

  ['schema', 'table'].forEach(function (identifier) {
    if (parsed[identifier].escaped) {
      // hdbext escapes the schema and table names.
      // If we have received them escaped, then we should unescape them
      // so that these identifiers do not get escaped twice.
      adapted[identifier] = unescape(parsed[identifier].escaped);
    } else if (parsed[identifier].unescaped) {
      // In XSC if we pass an unescaped identifier, it is treated as upper case name.
      // We need to manually convert it to upper case
      // before hdbext escapes the identifier.
      adapted[identifier] = parsed[identifier].unescaped.toUpperCase();
    }
  });

  return adapted;
}

function unescape(identifier) {
  identifier = identifier.substring(1, identifier.length - 1);
  identifier = identifier.replace(/""/g, '"');
  return identifier;
}
