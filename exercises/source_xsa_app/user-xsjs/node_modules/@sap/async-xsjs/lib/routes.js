'use strict';

var http = require('http');
var format = require('util').format;
var fs = require('fs');
var path = require('path');
var xssSecure = require('@sap/xss-secure');
var logging = require('./logging');
var wrapAppError = require('./utils/errors/wrap-app-error');

var errorPageTemplate = fs.readFileSync(path.join(__dirname, 'views', 'error.html')).toString();

exports.xsjs = function (rt) {
  return async function xsjsHandler(req, res, next) {
    var pathToScript = res.locals.pathToScript;
    req.loggingContext.getTracer(__filename).info('Running script "%s"', pathToScript);
    try {
      await rt.runXsjs(pathToScript, req.$);
      req.$.response._pipe(res);
    } catch (err) {
      next(err);
    } finally {
      cleanUp(rt, req);
    }
  };
};

exports.xsodata = function (rt, odataService) {
  return function _odataRouteHandler(req, res, next) {
    var odataPath = odataService.getRootUriPath();
    var tracer = req.loggingContext.getTracer(__filename);
    tracer.info('Starting OData handling for request "%s%s"', odataPath, req.path);
    try {
      odataService.handle(req, res, function (err) {
        rt.triggerGc();
        if (err) {
          return next(err);
        }
        tracer.info('Finished OData handling for request "%s%s"', odataPath, req.path);
      });
    } catch (err) {
      next(err);
    }
  };
};

exports.startJob = function (jobsRt, options) {
  return async function (req, res, next) { // eslint-disable-line no-unused-vars
    var logger = req.loggingContext.getLogger(logging.CATEGORY);
    var tracer = req.loggingContext.getTracer(__filename);
    if (!options.anonymous && options.uaa) {
      var scope = options.uaa.xsappname + '.JOBSCHEDULER';
      if (req.authInfo && !req.authInfo.checkScope(scope)) {
        logger.error('Job "%s" - required scope "%s" is missing', req.path, scope);

        var auditLog = req.app.get('auditLog');
        if (!auditLog) {
          return res.status(403).end();
        }

        var message = format('Job "%s", received token does not contain required scope: %s', req.path, scope);
        return auditLog.logSecurityEvent(req, message, 'Technical user', function (err) {
          if (err) {
            return next(err);
          }
          res.status(403).end();
        });
      }
    }

    tracer.info('Starting job "%s"', req.path);
    try {
      await jobsRt.startJobAsync(req);
      res.status(202).json({ success: true });
      tracer.info('Job "%s" started', req.path);
    } catch (err) {
      logger.error(wrapAppError(err), format('Failed to start job "%s"', req.path));
      res.status(500).json({ error: err.message ? err.message : err });
    }
  };
};

exports.error = function (err, req, res, next) { // eslint-disable-line no-unused-vars
  var status = http.STATUS_CODES[err.status] ? err.status : 500;
  var logger = req.loggingContext.getLogger(logging.CATEGORY);

  if (status >= 400 && status < 500) {
    logger.info('%s %s returning status %d (%s)', req.method, req.originalUrl, status, err.message);
  } else {
    logger.error(wrapAppError(err), format('%s %s returning status %d', req.method, req.originalUrl, status));
  }

  var title;
  var stacktrace = '';
  if (process.env.NODE_ENV === 'development') {
    title = status + ' ' + err.message;
    stacktrace = err.stack || '';
  } else {
    // do not reveal internal details to the client
    title = status + ' ' + http.STATUS_CODES[status];
  }
  title = xssSecure.encodeHTML(title);
  stacktrace = xssSecure.encodeHTML(stacktrace);

  var errorPage = errorPageTemplate.replace(/<%= title %>/g, title);
  errorPage = errorPage.replace('<%= stacktrace %>', stacktrace && ('<pre>' + stacktrace + '</pre>'));
  res.set('Content-Type', 'text/html');
  res.status(status).send(errorPage);
};

function cleanUp(rt, req) {
  rt.cleanupContext(req.$);
  req.$ = undefined;
  rt.triggerGc();
}
