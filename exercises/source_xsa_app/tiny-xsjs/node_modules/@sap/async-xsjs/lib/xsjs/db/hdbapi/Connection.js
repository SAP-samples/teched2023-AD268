'use strict';

var _ = require('lodash');
var assert = require('assert');
var FunctionCode = require('@sap/hana-client/extension/FunctionCode');
var enums = require('../common/enums');
var executeBatchPromise = require('../common/execute-batch').executeBatchPromise;
var ResultSetIterator = require('./ResultSetIterator.js');
var ctypes = require('../../../ctypes');
var convert = require('./convert');
var hdbext = require('@sap/hdbext');
var DB_TYPE = require('@sap/hana-client/extension/TypeCode');
var bufferUtils = require('../../../utils/buffer-utils');
var dateUtils = require('../../../utils/date-utils');
var moment = require('moment');

module.exports = Connection;

/**
 * @class $.hdb.Connection
 * @classdesc HANA database connection.
 * @constructor
 */
function Connection(tracer, client, treatDateAsUTC, enableColumnIndices) {
  assert(typeof client === 'object', 'A valid client object should be provided to create $.hdb.Connection');
  this._tracer = tracer;
  this._client = client;
  this._treatDateAsUTC = treatDateAsUTC;
  this._enableColumnIndices = enableColumnIndices;
}

/**
 * Returns underlying client object
 */
Connection.prototype.getClient = function () {
  return this._client;
};

/**
 * Closes the connection
 * @throws Throws an error if the operation fails.
 */
Connection.prototype.close = async function () {
  await this._client.close();
};

/**
 * Commits the changes and ends the current transaction. <b>By default autocommit mode is disabled, which means all database changes must be explicitly commited.</b>
 * @throws Throws an error if the operation fails.
 * @example
 *
 * var connection = $.hdb.getConnection();
 * connection.executeUpdate('UPDATE "DB_EXAMPLE"."ICECREAM" SET QUANTITY=? WHERE FLAVOR=?', 9, 'CHOCOLATE');
 * connection.commit();
 */
Connection.prototype.commit = async function () {
  await this._client.commit();
};

/**
 * Reverts the changes and ends the current transaction.
 * @throws Throws an error if the operation fails.
 * @example
 *
 * var connection = $.hdb.getConnection();
 * connection.executeUpdate('UPDATE "DB_EXAMPLE"."ICECREAM" SET QUANTITY=? WHERE FLAVOR=?', 9, 'CHOCOLATE');
 * connection.rollback();
 */
Connection.prototype.rollback = async function () {
  await this._client.rollback();
};

/**
 * Changes the auto-commit flag of the connection.
 * @param {bool} autoCommit A bool value, which can be true or false
 */
Connection.prototype.setAutoCommit = function (autoCommit) {
  this._client.setAutoCommit(autoCommit);
};

/**
 * Executes a database query.
 * @param {string} query The query string to be executed.
 * @param {...varArgs} [arguments] Variable number of arguments to be bound to the query parameters.
 * @returns {$.hdb.ResultSet}
 * @throws Throws an error if the statement cannot be executed.
 * @example
 * var connection = $.hdb.getConnection();
 * connection.executeQuery('SELECT * FROM "DB_EXAMPLE"."ICECREAM"');
 * connection.executeQuery('SELECT * FROM "DB_EXAMPLE"."ICECREAM" WHERE FLAVOR = ?', 'CHOCOLATE');
 * connection.executeQuery('SELECT * FROM "DB_EXAMPLE"."ICECREAM" WHERE FLAVOR = ? AND PRICE < ?', 'STRAWBERRY', 2.50);
 */
Connection.prototype.executeQuery = async function () {
  var args = Array.prototype.slice.call(arguments);
  args = normalizeInput(args, this._treatDateAsUTC);
  var rs = await executePromise(this._tracer, this._client, args.shift(), args);
  return processResultSet(rs, this._treatDateAsUTC, this._enableColumnIndices);
};

/**
 * Executes a SQL statement, which changes the database state. SELECT and CALL statements are not allowed here.
 * @param {string} statement The statement to be executed.
 * @param {...varArgs} [arguments] Variable number of arguments to be bound to the query parameters.
 * @returns {number|array} Number of affected rows | Array of numbers in case of batch update.
 * @throws Throws an error if the statement cannot be executed.
 * @example
 *
 * var connection = $.hdb.getConnection();
 * connection.executeUpdate('INSERT INTO "DB_EXAMPLE"."ICECREAM" VALUES (?,?,?)','STRAWBERRY', 2.50, 64.18);
 * connection.executeUpdate('UPDATE "DB_EXAMPLE"."CASH" SET INCOME=?', 64.18);
 * connection.executeUpdate('DELETE FROM "DB_EXAMPLE"."ICECREAM" WHERE FLAVOR = ?', 'STRAWBERRY');
 *
 * // Batch Insert
 * var argsArray = [["MINT", 3.50, 34.5], ["VANILLA", 2.50, 23.6], ["CHERRY", 4.50, 67.9]];
 * connection.executeUpdate('INSERT INTO "DB_EXAMPLE"."ICECREAM" VALUES (?,?,?)', argsArray)
 * connection.commit();
 */
Connection.prototype.executeUpdate = async function () {
  var args = Array.prototype.slice.call(arguments);
  args = normalizeInput(args, this._treatDateAsUTC);
  var result = await executePromise(this._tracer, this._client, args.shift(), args);
  return result;
};

/**
 * Returns a JavaScript function representing the stored procedure being loaded.
 * @param {string} [schema] The schema to which the procedure belongs.
 * @param {string} procedure The name of the procedure.
 * @returns {function}
 * @example
 *
 * var connection = $.hdb.getConnection();
 * // looks for the stored procedure in the current schema
 * var fnSell = connection.loadProcedure('icecream.shop::sell');
 * // the procedure has signature 'DB_EXAMPLE'.'icecream.shop::sell'(IN flavor VARCHAR, IN quantity INTEGER, IN payment DECIMAL, OUT change DECIMAL)
 * var fnSell = connection.loadProcedure('DB_EXAMPLE', 'icecream.shop::sell');
 * // call the procedure just like calling a javascript function
 * // sell three ice cream cups with chocolate flavor for 20 bucks each
 * var result = fnSell('CHOCOLATE', 3, 20.00);
 * // alternatively use named parameters
 * var result = fnSell({FLAVOR: 'CHOCOLATE', QUANTITY: 3, PAYMENT: 20.00});
 * // result is a $.hdb.ProcedureResult object
 *
 * @example
 * <b><font size="4">Table Parameter Support For Stored Procedures</font></b>
 *
 * // the procedure has signature 'DB_EXAMPLE'.'icecream.shop::lower_price_by'(IN ice_cream_prices prices_table_type, IN lower_price_by DOUBLE, OUT new_ice_cream_prices prices_table_type)
 * var fnlowerPrice = connection.loadProcedure('DB_EXAMPLE', 'icecream.shop::lower_price_by');
 *
 * // passing a $.hdb.ResultSet object
 * var price_list = connection.executeQuery('SELECT * FROM "DB_EXAMPLE"."SOLD_FLAVORS_PRICES"');
 * var result = fnlowerPrice(price_list, 1.50);
 *
 * // passing a string containing the name of existing table in the database
 * var result = fnlowerPrice('"DB_EXAMPLE"."SOLD_FLAVORS_PRICES"', 1.50);
 *
 * // passing an array of JSON objects representing the rows in the table
 * var price_list = [{FLAVOR: 'STRAWBERRY', PRICE: 4.50}, {FLAVOR : 'VANILLA', PRICE: 3.50}, {FLAVOR: 'CHOCOLATE', PRICE: 5.50}];
 * var result = fnlowerPrice(price_list, 1.50);
 *
 * // We can get the table output parameter "new_ice_cream_prices" like any other output parameter:
 * var new_price_list = result.NEW_ICE_CREAM_PRICES;
 * // new_price_list is a $.hdb.ResultSet object
 */
Connection.prototype.loadProcedure = async function (schema, name) {
  var treatDateAsUTC = this._treatDateAsUTC;
  var enableColumnIndices = this._enableColumnIndices;
  if (arguments.length === 1) {
    name = arguments[0];
    schema = undefined;
  }

  var storedProc = await hdbext.loadProcedurePromise(this._client, schema, name);

  return callsp.bind(this);

  function callsp() {
    var inargs = Array.prototype.slice.call(arguments);
    return new Promise ((resolve, reject) => {
      inargs = normalizeInput(inargs, treatDateAsUTC);
      inargs = convertInput(this._tracer, inargs, storedProc.paramsMetadata);

      // Workaround for named paramaters - @sap/hana-client uses 'instanceof Object' (to validate its input)
      // which returns false for an object created in a different context.
      // This is why we need to create the object in the same context.
      if (usingNamedParameters(inargs)) {
        inargs[0] = _.extend({}, inargs[0]);
      }

      var ondone = function () {
        var args = arguments;
        var at = 0;

        var err = args[at++];
        if (err) {
          return reject(err);
        }

        var parameters = args[at++] || {};

        storedProc.paramsMetadata.forEach(function (i) {
          if (i.DATA_TYPE_NAME === 'TABLE_TYPE' && i.PARAMETER_TYPE === 'OUT') {
            parameters[i.PARAMETER_NAME] = processResultSet(args[at++], treatDateAsUTC, enableColumnIndices);
          }
          if (!isOutgoing(i) || parameters[i.PARAMETER_NAME] === null) {
            return;
          }

          if (i.DATA_TYPE_NAME === 'BIGINT') {
            parameters[i.PARAMETER_NAME] = new ctypes.Int64(parameters[i.PARAMETER_NAME]);
          }
          if (i.DATA_TYPE_NAME === 'BLOB' || i.DATA_TYPE_NAME === 'BINARY' || i.DATA_TYPE_NAME === 'VARBINARY') {
            parameters[i.PARAMETER_NAME] = bufferUtils.toArrayBuffer(parameters[i.PARAMETER_NAME]);
          }
          if (i.DATA_TYPE_NAME === 'CLOB' || i.DATA_TYPE_NAME === 'NCLOB') {
            if (Buffer.isBuffer(parameters[i.PARAMETER_NAME])) {
              parameters[i.PARAMETER_NAME] = parameters[i.PARAMETER_NAME].toString();
            }
          }
          if (i.DATA_TYPE_NAME === 'DATE') {
            parameters[i.PARAMETER_NAME] = dateUtils.dateToJsDate(parameters[i.PARAMETER_NAME], treatDateAsUTC);
          }
          if (i.DATA_TYPE_NAME === 'TIME') {
            parameters[i.PARAMETER_NAME] = dateUtils.timeToJsDate(parameters[i.PARAMETER_NAME], treatDateAsUTC);
          }
          if (i.DATA_TYPE_NAME === 'SECONDDATE' || i.DATA_TYPE_NAME === 'TIMESTAMP') {
            parameters[i.PARAMETER_NAME] = dateUtils.dateTimeToJsDate(parameters[i.PARAMETER_NAME], treatDateAsUTC);
          }
        });

        var spResultSets = [];
        while (at < args.length) {
          spResultSets.push(processResultSet(args[at++], treatDateAsUTC, enableColumnIndices));
        }

        Object.defineProperty(parameters, '$resultSets', { enumerable: false, value: spResultSets });
        resolve(parameters);
      };
      inargs.push(ondone);
      storedProc.apply(null, inargs);
    });
  }
};

function usingNamedParameters(input) {
  return input.length === 1 && _.isObject(input[0]) &&
    !_.isArray(input[0]) && !Buffer.isBuffer(input[0]);
}

function convertInput(tracer, input, paramsMetadata) {
  if (!paramsMetadata) {
    return input;
  }

  if (usingNamedParameters(input)) {
    paramsMetadata.forEach(function(metadata) {
      var value = input[0][metadata.PARAMETER_NAME];
      if (value) {
        input[0][metadata.PARAMETER_NAME] = convert(tracer, value, metadata.DATA_TYPE_NAME);
      }
    });
  } else {
    var inParamsMetadata = paramsMetadata.filter(function (meta) {
      return meta.PARAMETER_TYPE !== 'OUT';
    });
    input.forEach(function (arg, index) {
      input[index] = convert(tracer, arg, inParamsMetadata[index].DATA_TYPE_NAME);
    });
  }

  return input;
}

function normalizeInput(input, treatDateAsUTC) {
  // process objects with special semantics
  if (input instanceof ctypes.Int64) {
    return input.valueOf();
  }

  if (_.isBuffer(input)) {
    return input;
  }

  if (_.isArrayBuffer(input)) {
    return bufferUtils.toBuffer(input);
  }

  if (_.isDate(input)) {
    return (treatDateAsUTC ? moment(input).utc() : moment(input)).format('YYYY-MM-DD HH:mm:ss.SSSSSSS');
  }

  // traverse container objects (including arrays)
  if (_.isObjectLike(input)) {
    for (var key in input) {
      input[key] = normalizeInput(input[key], treatDateAsUTC);
    }
    return input;
  }

  return input;
}

function isOutgoing(procParam) {
  return procParam.PARAMETER_TYPE === 'INOUT' || procParam.PARAMETER_TYPE === 'OUT';
}

function processResultSet(rs, treatDateAsUTC, enableColumnIndices) {
  Object.defineProperty(rs, 'getIterator', {
    enumerable: false,
    value: function () {
      return new ResultSetIterator(rs);
    }
  });

  var names = getNamesOfColumnsForProcessing(rs.columnInfo);
  var row;
  for (var bigIntColumn of names.bigIntColumns) {
    for (row of rs) {
      if (row[bigIntColumn] !== null) {
        row[bigIntColumn] = new ctypes.Int64(row[bigIntColumn]);
      }
    }
  }
  for (var binaryColumn of names.binaryColumns) {
    for (row of rs) {
      if (row[binaryColumn] !== null) {
        row[binaryColumn] = bufferUtils.toArrayBuffer(row[binaryColumn]);
      }
    }
  }
  for (var dateColumn of names.dateColumns) {
    for (row of rs) {
      if (row[dateColumn] !== null) {
        row[dateColumn] = dateUtils.dateToJsDate(row[dateColumn], treatDateAsUTC);
      }
    }
  }
  for (var timeColumn of names.timeColumns) {
    for (row of rs) {
      if (row[timeColumn] !== null) {
        row[timeColumn] = dateUtils.timeToJsDate(row[timeColumn], treatDateAsUTC);
      }
    }
  }
  for (var dateTimeColumn of names.dateTimeColumns) {
    for (row of rs) {
      if (row[dateTimeColumn] !== null) {
        row[dateTimeColumn] = dateUtils.dateTimeToJsDate(row[dateTimeColumn], treatDateAsUTC);
      }
    }
  }

  var result = rs;
  if (enableColumnIndices) {
    result = attachColumnIndices(rs);
  }

  attachResultSetMetadata(rs);
  return result;
}

function getNamesOfColumnsForProcessing(columnInfo) {
  var names = {
    bigIntColumns: [],
    binaryColumns: [],
    dateColumns: [],
    timeColumns: [],
    dateTimeColumns: []
  };

  for (var info of columnInfo) {
    switch (info.nativeType) {
    case DB_TYPE.BIGINT:
      names.bigIntColumns.push(info.columnName);
      break;
    case DB_TYPE.BLOB:
    case DB_TYPE.BINARY:
    case DB_TYPE.VARBINARY:
      names.binaryColumns.push(info.columnName);
      break;
    case DB_TYPE.DAYDATE:
      names.dateColumns.push(info.columnName);
      break;
    case DB_TYPE.SECONDTIME:
      names.timeColumns.push(info.columnName);
      break;
    case DB_TYPE.SECONDDATE:
    case DB_TYPE.LONGDATE:
      names.dateTimeColumns.push(info.columnName);
      break;
    default:
      break;
    }
  }

  return names;
}

function attachColumnIndices(rs) {
  const columnIndexObject = createColumnIndexObject(rs.columnInfo);

  rs.forEach((row, index, rs) => {
    rs[index] = Object.assign(Object.create(columnIndexObject), row);
  });

  updateColumnIndexObject(columnIndexObject, rs.columnInfo);
  return rs;
}

function createColumnIndexObject(columnInfo) {
  const properties = {};

  for (let index in columnInfo) {
    properties[index] = {
      enumerable: false,
      configurable: true,
      set: function (value) {
        this[Symbol.for(index)] = value;
      }
    };
  }

  return Object.defineProperties({}, properties);
}

function updateColumnIndexObject(columnIndexObject, columnInfo) {
  const properties = {};

  for (let index in columnInfo) {
    properties[index] = {
      enumerable: false,
      configurable: false,
      set: function () {
        throw new Error(`"${index}" is read-only`);
      },
      get: function () {
        const columnName = columnInfo[index].columnName;
        const valueByIndex = this[Symbol.for(columnName)];
        return valueByIndex !== undefined ? valueByIndex : this[columnName];
      }
    };
  }

  return Object.defineProperties(columnIndexObject, properties);
}

function attachResultSetMetadata(rs) {
  var columnsMetadata = [];
  for (var i = 0; i < rs.columnInfo.length; ++i) {
    var info = rs.columnInfo[i];
    var metadata = {
      label: info.columnName,
      name: info.originalColumnName,
      type: enums.convert.toXscType(info.nativeType),
      typeName: enums.convert.toXscTypeName(info.nativeTypeName),
      precision: info.precision,
      scale: info.scale,
      tableName: info.tableName,
      isNullable: !!info.nullable
    };
    columnsMetadata.push(metadata);
  }
  Object.defineProperty(rs, 'metadata', {
    value: { columns: columnsMetadata }
  });
}

async function executePromise(tracer, client, sql, sqlArgs) {
  if (!_.isString(sql)) {
    throw ('Invalid sql');
  }

  var args = sqlArgs || [];
  var isBatch = args.length === 1 && Array.isArray(args[0]);
  if (isBatch) {
    args = args[0];
  }

  var statement = await client.prepare(sql);
  try {
    args = applyDefaultConversions(tracer, args, statement.getParameterInfo());
  } catch (err) {
    await afterStatementDropPromise(tracer, statement);
  }
  var fnCode = statement.functionCode();
  if (fnCode === FunctionCode.NIL || fnCode === FunctionCode.DDL ||
      fnCode === FunctionCode.INSERT || fnCode === FunctionCode.UPDATE || fnCode === FunctionCode.DELETE)
  {
    var result;
    if (isBatch) {
      result = await executeBatchPromise(statement, args);
    } else {
      result = await statement.execute(args);
    }
    return result;
  } else {

    var rows = await statement.execute(args) || [];
    Object.defineProperty(rows, 'columnInfo', { value: statement.getColumnInfo() });
    await afterStatementDropPromise(tracer, statement);
    return rows;
  }
}

async function afterStatementDropPromise(tracer, stmt){
  try {
    await stmt.drop();
  } catch (err) {
    tracer.debug(err, 'Could not drop statement');
  }
}

function applyDefaultConversions(tracer, sqlArgs, parameterInfo) {
  return sqlArgs.map(function(current, i) {
    if (_.isArray(current)) {
      return current.map(function(arg, j) {
        if (j < parameterInfo.length) {
          return convert(tracer, arg, parameterInfo[j].nativeType);
        }
      });
    }

    return convert(tracer, current, parameterInfo[i].nativeType);
  });
}
