'use strict';

var _ = require('lodash');
var connection = require('./connection');
var enums = require('./enums');

module.exports = DbBase;

function DbBase(dbReqOptions) {
  this._dbReqOptions = dbReqOptions;
  this._openConnections = new Set();
}

DbBase.prototype.isolation = enums.isolationLevel.XSC;
DbBase.prototype.types = enums.types.XSC;

DbBase.prototype._getClient = async function (userOptions) {
  var sqlccName = getSqlccName(userOptions);
  var hanaOptions = (sqlccName) ?
    this._dbReqOptions.getSqlccOptions(sqlccName) :
    await this._dbReqOptions.getInstanceOptionsPromise();

  hanaOptions = mergeUserOptions(hanaOptions, userOptions);
  this._options = hanaOptions; // used by $.text
  var client = await connection.connect(hanaOptions);

  var openConnections = this._openConnections;
  openConnections.add(client);

  var originalClose = client.close;

  Object.defineProperty(client, 'close', {
    writable: true,
    value: function () {
      openConnections.delete(client);
      client.close = originalClose;
      originalClose.apply(client, arguments);
    }
  });

  return client;
};

DbBase.prototype._closeAllConnections = function () {
  for (var client of this._openConnections) {
    client.close(function() { }); // ignoring an error here
  }
  this._openConnections.clear();
};

function getSqlccName(userOptions) {
  userOptions = userOptions || {};
  if (!userOptions.sqlcc) {
    return;
  }

  if (!_.isString(userOptions.sqlcc)) {
    throw new TypeError('The provided SQLCC name is not a string');
  }

  var sqlccName = userOptions.sqlcc.trim();
  if (!sqlccName) {
    throw new TypeError('The provided SQLCC name is empty string or contains only whitespaces');
  }
  return sqlccName;
}

function extractUserOptions(userOptions) {
  var acceptedProperties = ['sqlcc', 'isolationLevel', 'locale', 'treatDateAsUTC'];
  var filtered = _.pick(userOptions, acceptedProperties);
  if (filtered.isolationLevel) {
    filtered.isolationLevel = enums.convert.toDriverIsolationLevel(filtered.isolationLevel);
  }
  if ('locale' in filtered && !filtered.locale) {
    // falsy values for locale provided in xsjs code are ignored
    delete filtered.locale;
  }
  return filtered;
}

function mergeUserOptions(options, userOptions) {
  userOptions = extractUserOptions(userOptions);
  var opt = _.extend({}, options, userOptions);
  return opt;
}
