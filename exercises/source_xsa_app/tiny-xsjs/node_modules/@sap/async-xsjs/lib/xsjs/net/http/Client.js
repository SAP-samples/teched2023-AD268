'use strict';

var util = require('util');
var qs = require('querystring');
var axios = require('axios');
var _ = require('lodash');
var SAPPassport = require('@sap/e2e-trace').Passport;
var WebResponse = require('../../web/WebResponse');
var CRLF = require('../../constants').WEB.MESSAGES.LINE_BREAK;
var MultipartResponseBuilder = require('../../web/utils/MultipartResponseBuilder');
var contentTypeParser = require('content-type');
var stream = require('stream');
var URL = require('url').URL;

var methodMapping = {
  // -1: 'INVALID',
  0: 'OPTIONS',
  1: 'GET',
  2: 'HEAD',
  3: 'POST',
  4: 'PUT',
  5: 'DELETE',
  6: 'TRACE',
  7: 'CONNECT',
  8: 'PATCH'
};

function Client(sapPassport) {
  if (!(this instanceof Client)) {
    return new Client(sapPassport);
  }
  this._response = null;
  this._sapPassport = sapPassport;
}

Client.prototype.getResponse = async function () {
  if (!this._response) {
    throw new Error('Make an HTTP request before trying to get the response');
  }
  if (util.types.isPromise(this._response)) {
    this._response = new WebResponse(await this._response);
  }
  return this._response;
};

Client.prototype.request = function (arg0, arg1, proxyOpt) {
  this._response = null;
  var options = {
    headers: {},
    timeout: 10000
  };
  if (this._sapPassport) {
    var passport = new SAPPassport(this._sapPassport);
    passport.update({
      connectionID: '00000000000000000000000000000000',
      connectionCounter: 0
    });
    options.headers[SAPPassport.HEADER_NAME] = passport.serialize();
  }
  if (_.isNumber(arg0)) {
    processWebMethodAndUrl(options, arg0, arg1, proxyOpt);
  } else if (_.isString(arg1)) {
    processWebRequestAndUrl(options, arg0, arg1, proxyOpt);
  } else {
    processWebRequestAndDestination(options, arg0, arg1);
  }

  if (this._timeoutInMilliseconds) {
    options.timeout = this._timeoutInMilliseconds;
  }

  options.validateStatus = function (status) {
    // succesfully resolve the promise for all status codes,
    // otherwise an error is thrown which is incompatible with the current WebResponse logic
    return status > 0;
  };
  this._response = axios.request(options)
      .then(response => {
        return response;
      })
      .catch(error => {
        throw error;
      });
  return this;
};

Client.prototype.setTimeout = function (timeout) {
  this._timeoutInMilliseconds = timeout * 1000;
};

Client.prototype.close = function () {
};

Client.prototype.setTrustStore = function () {
  throw new Error('Feature not supported!');
};

function processWebMethodAndUrl(options, webMethod, url, proxyOpt) {
  options.url = url;
  options.method = methodMapping[webMethod];
  setProxy(options, proxyOpt);
}

function processWebRequestAndUrl(options, webRequest, url, proxyOpt) {
  options.url = url;
  useDataFromWebRequest(options, webRequest);
  setProxy(options, proxyOpt);
}

function processWebRequestAndDestination(options, webRequest, destination) {
  options.url = (destination.useSSL === true ? 'https://' : 'http://') + destination.host + ':' + destination.port;
  if (destination.timeout) {
    options.timeout = destination.timeout;
  }
  addPathPrefix(options, destination);
  useDataFromWebRequest(options, webRequest);
  setProxyFromDestination(options, destination);
  setBasicAuthFromDestination(options, destination);
}

function useDataFromWebRequest(options, webRequest) {
  options.method = methodMapping[webRequest.method];
  addPath(options, webRequest);
  addRequestParameters(options, webRequest);
  handleEntities(options, webRequest);
  addHeaders(options, webRequest);
  addCookies(options, webRequest);
  addBody(options, webRequest);
}

function handleEntities(options, webRequest) {
  let multiPartHeader = webRequest.headers.get('content-type');
  if (webRequest.entities.length > 0 && multiPartHeader && multiPartHeader.indexOf('multipart') > -1) {
    let boundary = '';
    if (multiPartHeader.indexOf('boundary') > -1) {
      boundary = contentTypeParser.parse(multiPartHeader).parameters.boundary;
    } else {
      boundary = MultipartResponseBuilder.generateBoundary();
      let multiPartHeaderWithBoundary = `${multiPartHeader};boundary=${boundary}`;
      webRequest.headers.set('content-type', multiPartHeaderWithBoundary);
    }

    if (multiPartHeader.indexOf('related') > -1) {

      options.data = buildMultipartRelatedData(webRequest, boundary);
    } else {
      throw new Error('Multipart/form-data and Multi-part/mixed are not supported!');
    }
  }
}

function buildMultipartRelatedData(webRequest, boundary) {
  const finale = `--${boundary}--`;
  const dataStream = new stream.PassThrough();
  let isStream = false;
  webRequest.entities.forEach(entity => {
    const preamble = `--${boundary}${CRLF}`;
    dataStream.push(preamble);
    if (entity.contentType) {
      dataStream.push(`content-type: ${entity.contentType}${CRLF}`);
    }
    dataStream.push(CRLF);
    let body = entity.body._content;
    if (body instanceof stream.Stream) {
      isStream = true;
      body.pipe(dataStream, {end: false});
      body.on('end', () => {
        dataStream.push(CRLF);
        dataStream.push(finale);
        dataStream.push(null);
      });
    } else {
      dataStream.push(body);
      dataStream.push(CRLF);
    }
  });
  if (!isStream) {
    dataStream.push(finale);
    dataStream.push(null);
  }
  return dataStream;
}

function addPath(options, webRequest) {
  if (webRequest.path) {
    if (options.url.charAt(options.url.length - 1) !== '/' && webRequest.path.charAt(0) !== '/') {
      options.url += '/';
    }
    options.url += webRequest.path;
  }
}

function addRequestParameters(options, webRequest) {
  if (webRequest.parameters.length > 0) {
    if (options.url.indexOf('?') !== -1) {
      options.url += '&';
    } else {
      options.url += '?';
    }
    options.url += qs.encode(webRequest.parameters.reduce(function (p, n) { p[n.name] = n.value; return p; }, {}));
  }
}

function addHeaders(options, webRequest) {
  webRequest.headers.forEach(function (header) {
    options.headers[header.name] = header.value;
  });
}

function addCookies(options, webRequest) {
  options.headers.Cookie = webRequest.cookies.map(function (cookie) {
    return cookie.name + '=' + cookie.value;
  }).join('; ');
}

function addBody(options, webRequest) {
  if (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH') {
    options.data = options.data || webRequest.body._content;
    options.responseType = 'text';
  }
}


function setProxy(options, proxyOpt) {
  if (proxyOpt) {
    options.proxy = new URL(proxyOpt);
  }
}

function addPathPrefix(options, destination) {
  if (destination.pathPrefix) {
    if (destination.pathPrefix.charAt(0) !== '/') {
      options.url += '/';
    }
    options.url += destination.pathPrefix;
  }
}

function setProxyFromDestination(options, destination) {
  if (destination.useProxy === true) {
    return options.proxy = new URL('http://' + destination.proxyHost + ':' + destination.proxyPort);
  }
  // explicitly disable proxy
  if (destination.useProxy === false) {
    options.proxy = null;
  }
}

function setBasicAuthFromDestination(options, destination) {
  if (destination.authType === 'basic') {
    options.auth = { username: destination.username, password: destination.password };
  }
}

module.exports = Client;
