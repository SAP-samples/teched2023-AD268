'use strict';

var _ = require('lodash');
var util = require('util');
// var fiber = require('@sap/fibers');

module.exports = XsjsJobRunner;

function XsjsJobRunner(rt) {
  if (!rt) {
    throw new Error('Valid xsjs runtime expected');
  }
  this._rt = rt;
  this._module = null;
  this._jsFunction = null;
}

XsjsJobRunner.prototype.prepare = async function(job, req, runId) {
  this._cleanup();
  this._assertValidJob(job);

  var rt = this._rt;
  var jsPath = job.action.getScriptPath();

  var context = rt.createBaseContext(req, null, { id: runId, location: job.urlPath });
  try {
    var module = await rt.runXsjs(jsPath, context);
  } finally {
    rt.cleanupContext(context);
  }

  var funcName = job.action.funcname;
  var jsFunction = module.namespace.default[funcName];
  if (!jsFunction) {
    throw new Error(util.format('XSJS "%s" doesn\'t have a function "%s"', jsPath, funcName));
  }
  if (!_.isFunction(jsFunction)) {
    throw new Error(util.format('"%s" is not a function in "%s"', funcName, jsPath));
  }

  this._module = module;
  this._jsFunction = jsFunction;
};

/**
 * Runs asynchronously
 * @param inputParams to be provided to XSJS function
 * @param done callback to notify when job finished
 */
XsjsJobRunner.prototype.run = async function(inputParams) {
  if (!this._jsFunction) {
    throw new Error('XsjsJobRunner: runner needs to be prepared before run is called');
  }

  var self = this;
  try {
    await self._jsFunction.call(this, inputParams || {});
  }
  finally {
    self._cleanup();
    self._rt.triggerGc();
  }
};

XsjsJobRunner.prototype._assertValidJob = function(job) {
  if (!job) {
    throw new TypeError('Valid job object should be provided');
  }

  if (!job.action.isJavaScript()) {
    throw new TypeError('Not a handler for SQL procedure based jobs, xsjob: ' + job.urlPath);
  }
};

XsjsJobRunner.prototype._cleanup = function() {
  this._module = null;
  this._jsFunction = null;
};
