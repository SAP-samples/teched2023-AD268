'use strict';

var assert = require('assert');
var util = require('util');

exports.runXsFunction = runXsFunction;
exports.createXsFunctionThisArg = createXsFunctionThisArg;

/**
 * Executes the given function from the xsjs script provided in the constructor.
 *
 * Note that although xsjs code is executed in a fiber, this function will run it asynchronously,
 * i.e. it will return when xsjs code executes the first async/blocking operation.
 *
 * @param {scriptRunner} object of type <code>{ runtime: {}, context: {}, pathToScript: '', runScript: function() {} }</code>.
 * Will be used to get the executed script where function with name 'functionName'
 * should exist and will be executed.
 * @param {string} functionName name of the function to execute
 * @param {object} thisArg the value of `this` provided to the function, can be null or undefined
 * @param {array} argsArray function arguments, can be null or undefined
 */
async function runXsFunction(scriptRunner, functionName, thisArg, argsArray) {
  assert(typeof scriptRunner === 'object', 'Valid script runner should to be provided');
  assert(functionName && typeof functionName === 'string', 'Invalid function name');
  assert(!argsArray || Array.isArray(argsArray), 'Pass function arguments as an array');
  var rt = scriptRunner.runtime;
  var context = scriptRunner.context;

  var module = null;
  try {
    module = await scriptRunner.runScript();
    var jsFunction = module[functionName];
    if (!jsFunction) {
      throw new Error(util.format('Function "%s" not found in script "%s"', functionName, scriptRunner.pathToScript));
    }
    if (typeof jsFunction !== 'function') {
      throw new Error(util.format('"%s" is not a function', functionName));
    }
    return jsFunction.apply(thisArg, argsArray);
  } finally {
    rt.cleanupContext(context);
    rt.triggerGc();
  }
}

function createXsFunctionThisArg(context) {
  return {
    $: context,
    xsengine: context
  };
}
