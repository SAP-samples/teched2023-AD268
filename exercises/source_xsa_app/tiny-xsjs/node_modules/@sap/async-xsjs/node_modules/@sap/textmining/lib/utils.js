/*
 * (c) Copyright 2015-2016 SAP SE. All rights reserved
 */

'use strict';

exports.checkIndexQueue = function checkIndexQueue(client, referenceTableArray, callback) {
  var waitForQueue = 'SELECT QUEUE_DOCUMENT_COUNT FROM "SYS"."M_FULLTEXT_QUEUES" WHERE ';
  if (referenceTableArray.length === 2) {
    waitForQueue += "SCHEMA_NAME = \'" + referenceTableArray[0] + "\' AND TABLE_NAME = \'" + referenceTableArray[1] + "\'";
  } else {
    waitForQueue += "TABLE_NAME = \'" + referenceTableArray[0] + "\'";
  }

  client.exec(waitForQueue, function (err, result) {
    if (err) {
      return callback(err);
    }
    if (result.length === 0) {
      return callback(new Error("Could not fetch index queue information, please make sure table name is correct."));
    } else if (result[0].QUEUE_DOCUMENT_COUNT === 0) {
      return callback(null);
    } else {
      setTimeout(function () {
        checkIndexQueue(client, referenceTableArray, callback);
      }, 300);
    }
  });
}

exports.checkParameters = function checkParameters(methodName, p, whatToCheck) {
  for(var i = 0; i < whatToCheck.length; ++i) {
    switch(whatToCheck[i]) {
      case 'inputDocument': {
        //check these three arguments, only one is allowed one time.
        var hasInputDocumentText = p.inputDocumentText !== undefined;
        var hasInputDocumentSubquery = p.inputDocumentSubquery !== undefined;
        var hasInputDocumentCondition = p.inputDocumentCondition !== undefined;
        if(hasInputDocumentText + hasInputDocumentSubquery + hasInputDocumentCondition !== 1) {
          return new Error("Method " + methodName + " only accepts one and only one of following parameters: inputDocumentText, inputDocumentSubquery and inputDocumentCondition as input document.");
        }
        else if(hasInputDocumentText && typeof p.inputDocumentText !== "string") {
          return new Error("Parameter \"inputDocumentText\" has to be string.");
        }
        else if(hasInputDocumentSubquery && typeof p.inputDocumentSubquery !== "string") {
          return new Error("Parameter \"inputDocumentSubquery\" has to be string.");
        }
        else if(hasInputDocumentCondition && typeof p.inputDocumentCondition !== "string") {
          return new Error("Parameter \"inputDocumentCondition\" has to be string.");
        }
        break;
      }
      case 'inputTerm': {
        if(p.inputTermText === undefined) {
          return new Error("Method " + methodName + " requires parameter \"inputTermText\".");
        }
        else if(typeof p.inputTermText !== "string") {
          return new Error("Parameter \"inputTermText\" has to be string.");
        }
        break;
      }
      case 'principalComponents': {
        if(p.principalComponents !== undefined && !(p.principalComponents === 0 || p.principalComponents === 1 || p.principalComponents === 2 || p.principalComponents === 3)) {
          return new Error("Parameter \"principalComponents\" only accepts integer among 0, 1, 2 and 3.");
        }
        break;
      }
      case 'clustering': {
        if(p.clustering !== undefined) {
          if(typeof p.clustering !== "string") {
            return new Error("Parameter \"clustering\" has to be string.");
          }
          else if(!(p.clustering.trim() === 'COMPLETE_LINKAGE' || p.clustering.trim() === 'SINGLE_LINKAGE' || p.clustering.trim() === 'AVG_DISTANCE_WITHIN' || p.clustering.trim() === 'AVG_DISTANCE_BETWEEN' || p.clustering.trim() === 'WARD')) {
            return new Error("Parameter \"clustering\" only accepts string among COMPLETE_LINKAGE, SINGLE_LINKAGE, AVG_DISTANCE_WITHIN ,AVG_DISTANCE_BETWEEN and WARD.");
          }
        }
        break;
      }
      case 'correlationMatrix': {
        if(p.correlationMatrix !== undefined && typeof p.correlationMatrix !== "boolean") {
          return new Error("Parameter \"correlationMatrix\" has to be boolean.");
        }
        break;
      }
      case 'includeColumns': {
        if(p.includeColumns !== undefined && !Array.isArray(p.includeColumns)) {
          return new Error("Parameter \"includeColumns\" has to be array.");
        }
        break;
      }
      case 'language': {
        if(p.language !== undefined && typeof p.language !== "string") {
          return new Error("Parameter \"language\" has to be string.");
        }
        break;
      }
      case 'mimetype': {
        if(p.mimetype !== undefined && typeof p.mimetype !== "string") {
          return new Error("Parameter \"mimetype\" has to be string.");
        }
        break;
      }
      case 'categorySets': {
        if(p.categorySets === undefined) {
          return new Error("Method categorizeKNN requires parameter \"categorySets\".");
        }
        else if(!Array.isArray(p.categorySets)) {
          return new Error("Parameter \"categorySets\" has to be array.");
        }
        break;
      }
      case 'kNN': {
        if(p.kNN !== undefined && typeof p.kNN !== "number") {
          return new Error("Parameter \"kNN\" has to be number.");
        }
        break;
      }
      case 'top': {
        if(p.top !== undefined && typeof p.top !== "number") {
          return new Error("Parameter \"top\" has to be number.");
        }
        break;
      }
      case 'threshold': {
        if(p.threshold !== undefined) {
          if(typeof p.threshold !== "number") {
            return new Error("Parameter \"threshold\" has to be number.");
          }
          else if(p.threshold < 0 || p.threshold > 1) {
            return new Error("Parameter \"threshold\" only accepts number from 0 to 1.");
          }
        }
        break;
      }
      case 'documentRestriction': {
        if(p.documentRestriction !== undefined && typeof p.documentRestriction !== "string") {
          return new Error("Parameter \"documentRestriction\" has to be string.");
        }
        break;
      }
      case 'termTypeRestriction': {
        if(p.termTypeRestriction !== undefined && typeof p.termTypeRestriction !== "string") {
          return new Error("Parameter \"termTypeRestriction\" has to be string.");
        }
        break;
      }
      default: continue;
    }
  }
}

exports.handleResults = function handleResults(results, whatToHandle) {
  for(var i = 0; i < results.length; ++i) {
    for(var j = 0; j < whatToHandle.length; ++j) {
      results[i][whatToHandle[j]] = parseFloat(Number(results[i][whatToHandle[j]]).toFixed(5));
    }
  }
  return results;
}
