'use strict';
const typeConverter = require('./../utils/typeConverter');
const EntityType = require('./entityType');
const Association = require('./association');

/**
 * EntityType
 * @type {Function}
 */

exports.entityKind = EntityType.entityKind;

exports.proprtyKind = {
    "Dimension": 1,
    "Measure": 2,
    "Parameter": 3
};


/**
 * Model
 * @type {Function}
 */
let Model = function Model(xsodata) {
    let property;
    this._runtimeDatabaseVersion = undefined; // if undefined->try to load, if null->loading version tried but unsuccessful (don't retry)
    this._service = xsodata.service;
    this._annotations = xsodata.annotations;
    this._areAnnotationsEnabled = this._annotations && this._annotations.enable === "OData4SAP";
    this._settings = xsodata.settings;
    this._scopes = this._service.scopes;


    //create entityType objects
    this._entityTypes = [];
    this._entityTypesMap = {};
    this._entityTypesMapUriId = {};

    //var entityTypeName = '';
    for (property in this._service.entityTypes) {
        if (this._service.entityTypes.hasOwnProperty(property)) {
            let entityType = new EntityType(this._service.entityTypes[property], this._settings);
            this._entityTypes.push(entityType);
            this._entityTypesMap[property] = entityType;

            //this is because for calc view the uri name is not the table and not the alias but defined py entity
            //e.g. "xsodata.test.tables::key_info" as "key_info1" aggregates always parameters via entity;
            //e.g. "xsodata.test.tables::key_info" as "key_info2" aggregates always parameters via entity "Input" results property "Answere";
            this._entityTypesMapUriId[entityType.getUriName()] = entityType;
        }
    }

    //create association objects
    this._associations = [];
    this._associationsMap = {};

    for (property in this._service.associations) {
        if (this._service.associations.hasOwnProperty(property)) {
            let association = new Association(this._service.associations[property]);
            this._associations.push(association);
            this._associationsMap[property] = association;
        }
    }
};

/**
 * getEntityType
 * @param entityType used in xsodata file for the entityType, if no alias defined the name behind '::' in the xsodata file
 * @returns {*}
 */
Model.prototype.getEntityType = function (entityType) {
    return this._entityTypesMap[entityType];
};

Model.prototype.getEntityTypeByUriId = function (entityType) {
    return this._entityTypesMapUriId[entityType];
};

Model.prototype.getEntityTypes = function () {
    return this._entityTypes;
};

Model.prototype.getAssociation = function (association) {
    return this._service.associations[association];
};

Model.prototype.getAssociationByName = function (associationName) {
    return this._associationsMap[associationName];
};

Model.prototype.getAssociations = function () {
    return this._associations;
};

Model.prototype.getScopes = function () {
    return this._scopes;
};

Model.prototype.getAssociationsMap = function () {
    return this._associationsMap;
};


Model.prototype.getNamespace = function () {
    return this._service.namespace || "default";
};

/**
 * Returns true if null values are enabled within the xsodata file, otherwise false
 * @returns {boolean}
 */
Model.prototype.isNullSupported = function () {
    if (this._settings) {
        return this._settings.support === "null";
    }
    return false;
};

Model.prototype.getSetting = function (category, topic) {
    if (this._settings && this._settings[category] && this._settings[category][topic]) {
        return this._settings[category][topic];
    }

    return false;
};

Model.prototype.getHints = function () {
    if (this._settings) {
        return this._settings.hints;
    }

    return null;
};

/*
For CV input parameters we define entities on the fly
 */
Model.prototype.addEntity = function (entityType) {
    this._entityTypes.push(entityType);
    this._entityTypesMap[entityType.name] = entityType;
    this._entityTypesMapUriId[entityType.getUriName()] = entityType;
};

Model.prototype.addAssociation = function (association) {
    this._associations.push(association);
    this._associationsMap[association.name] = association;
};

/**
 * Indicates, whether CSDL annotations are enabled for the current service, i.e. whether the annotations should be
 * serialized in the $metadata document.
 *
 * @returns {boolean} <code>true<code/> if "annotations {enable OData4SAP;}" configuration is specified in the xsodata
 * file and <code>false<code/> otherwise.
 */
Model.prototype.areAnnotationsEnabled = function areAnnotationsEnabled() {
    return this._areAnnotationsEnabled;
};

/**
 * Set the HANA database version (e.g. "2.00.030.00.1511255498")
 * @param {?string} version
 */
Model.prototype.setDbVersion = function setDbVersion(version) {
    this._runtimeDatabaseVersion = version;
};

/**
 * get the HANA database version (e.g. "2.00.030.00.1511255498")
 * @returns {string}
 */
Model.prototype.getDbVersion = function getDbVersion() {
    return this._runtimeDatabaseVersion;
};

//Code
let Metadata = function (columns) {

    this._rawColumns = columns;//was .columns
    this.propertyMap = {};
    this.converterMapToJsonPayload = {};
    this.converterMapToXMLPayload = {};
    let x;
    for (x = 0; x < columns.length; x++) {
        this.propertyMap[columns[x].COLUMN_NAME] = columns[x];
    }

    for (x = 0; x < columns.length; x++) {
        this.converterMapToJsonPayload[columns[x].COLUMN_NAME] = typeConverter.converterFunctions.dbNameToJsonPayload[columns[x].DATA_TYPE_NAME];
        this.converterMapToXMLPayload[columns[x].COLUMN_NAME] = typeConverter.converterFunctions.dbNameToXmlPayload[columns[x].DATA_TYPE_NAME];

    }
};

Metadata.prototype.getProperty = function getProperty(name) {
    return this.propertyMap[name];
};

Metadata.prototype.getColumns = function getColumns() {
    return this._rawColumns;
};

Metadata.prototype.getColumnsMap = function getColumns() {
    return this.propertyMap;
};


exports.Model = Model;
exports.Metadata = Metadata;
