'use strict';
var fs = require('fs');

/**
 * @classdesc Parse a Java .properties definition
 * @param {string} content Content of the .properties file to parse
 * @constructor
 */
function PropertiesParser(content) {
    this.properties = {};
    _parse(content || '', this);
}
module.exports = PropertiesParser;

/**
 * Loads and parses a .properties file
 * @param {string} propertyFile Path to the .properties file (must be UTF-8 encoded)
 * @return {Promise} Returns a promise eventually fulfilled to a newly created PropertiesParser
 */
PropertiesParser.load = function (propertyFile) {
    return new Promise(
        function (resolve, reject) {
            fs.readFile(propertyFile, {
                encoding: 'utf-8'
            }, function (err, content) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(content);
                }
            });
        })
        .then(function (content) {
            return new PropertiesParser(content);
        });
};

/**
 * Loads and parses synchronously a .properties file
 * @param {string} propertyFile Path to the .properties file (must be UTF-8 encoded)
 * @return {PropertiesParser} Returns a newly created PropertiesParser
 */
PropertiesParser.loadSync = function (propertyFile) {
    var content = fs.readFileSync(propertyFile, {
        encoding: 'utf-8'
    });
    return new PropertiesParser(content);
};

PropertiesParser.prototype.getProperty = function (key, defaultValue) {
    var value = this.properties[key];
    if (typeof value === 'string') {
        return value;
    }
    else if (defaultValue) {
        return defaultValue;
    }
    return null;
};

PropertiesParser.prototype.getKeys = function () {
    return Object.keys(this.properties);
};

PropertiesParser.prototype.setProperty = function (key, value) {
    if (typeof value !== 'string') {
        return;
    }
    this.properties[key] = value;
};

/**
 * RegExp that splits line and ignore leading white spaces
 * A non capturing group must be used for \r\n|\r|\n so that they to not appear in the array of lines
 * @private
 */
var splitRegExp = /(?:\r\n|\r|\n)[ \t\f]*/;

/**
 * RegExp that handles escapes, continuation line markers and key/value separators
 *
 *          [---unicode escape--] [esc] [cnt] [---key/value separator---]
 * @private
 */
var escapeRegExp = /(\\u[0-9a-fA-F]{0,4})|(\\.)|(\\$)|([ \t\f]*[ \t\f:=][ \t\f]*)/g;


// Special escape characters as supported by properties format. See JDK API doc for java.util.Properties for more information.
var escapeSpecialChars = {
    '\\f': '\f',
    '\\n': '\n',
    '\\r': '\r',
    '\\t': '\t'
};

function _parse(text, propertiesParser) {
    var line;
    var key;
    var value;
    var boolKey;
    var i;
    var match;
    var lastIndex;

    var lines = text.split(splitRegExp); // Split file into lines. Removes leading white spaces.

    propertiesParser.properties = {};

    for (i = 0; i < lines.length; i++) {
        line = lines[i];
        // ignore empty lines
        if (line === '' || line.charAt(0) === '#' || line.charAt(0) === '!') {
            continue;
        }

        escapeRegExp.lastIndex = lastIndex = 0;
        value = '';
        boolKey = true;

        while ((match = escapeRegExp.exec(line)) !== null) {
            // handle any raw, unmatched input
            if (lastIndex < match.index) {
                value += line.slice(lastIndex, match.index);
            }
            lastIndex = escapeRegExp.lastIndex;
            if (match[1]) {
                // unicode escape
                if (match[1].length !== 6) {
                    throw new Error('Incomplete Unicode Escape \'' + match[1] + '\'');
                }
                value += String.fromCharCode(parseInt(match[1].slice(2), 16));
            }
            else if (match[2]) {
                // special or simple escape
                value += escapeSpecialChars[match[2]] || match[2].slice(1);
            }
            else if (match[3]) {
                // continuation line marker
                line = lines[++i];
                escapeRegExp.lastIndex = lastIndex = 0;
            }
            else if (match[4]) {
                // key/value separator
                if (boolKey) {
                    boolKey = false;
                    key = value;
                    value = '';
                }
                else {
                    value += match[4];
                }
            }
        }
        if (lastIndex < line.length) {
            value += line.slice(lastIndex);
        }
        if (boolKey) {
            key = value;
            value = '';
        }
        propertiesParser.properties[key] = value;
    }
}
