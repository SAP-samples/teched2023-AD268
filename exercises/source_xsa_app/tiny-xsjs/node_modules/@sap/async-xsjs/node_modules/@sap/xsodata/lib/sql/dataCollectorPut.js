'use strict';

//Include
const dataCollector2 = require('./dataCollector2');
const sqlStatement = require('./sqlStatement');
const statementProcessor = require('./statementProcessor');
const utils = require('../utils/utils');
const SqlError = require('../utils/errors/sqlError');

exports.moveRecordNV_ToInsertTmpStm = function (context, asyncDone) {
    context.logger.silly('dataCollector', 'moveRecordNV_ToInsertTmpStm');
    //get dbSegment for inserting the payload
    var dbSeg = context.oData.dbSegmentLast;
    var stm = dbSeg.sql.stmContainer.insertTmp;
    if (!stm) {
        return asyncDone("Internal server error", context);
    }

    var max = dbSeg._recordNV.length;
    var i;
    for (i = 0; i < max; i++) {
        var nv = dbSeg._recordNV[i];
        stm.setValue(nv.name, nv.value, dbSeg.entityType.propertiesMap[nv.name].DATA_TYPE_NAME); // OK
    }
    return asyncDone(null, context);
};


exports.createTmpTables = function (context, asyncDone) {
    var dbSeg = context.oData.dbSegmentLast;
    var stms = [dbSeg.sql.stmContainer.createTmpOld, dbSeg.sql.stmContainer.createTmp];
    return statementProcessor.execStmsDirectlyNoResult(context,stms,  asyncDone);

};

exports.checkForAutoKeyGenUsage = function (context, asyncDone) {
    context.logger.silly('dataCollectorPut', 'checkForAutoKeyGenUsage');

    var dbSeg = context.oData.dbSegmentLast;
    if (!dbSeg.entityType.hasAdmindata()) {
        return asyncDone(null, context);
    }


    var stm = dbSeg.sql.stmContainer.insertTmp;
    var appData = {};
    var i;
    var nv = stm.nv;
    var name = '';

    const createBy = dbSeg.entityType.getAddAdmindata('create', 'by');
    const createAt = dbSeg.entityType.getAddAdmindata('create', 'at');
    const modifyBy = dbSeg.entityType.getAddAdmindata('modify', 'by');
    const modifyAt = dbSeg.entityType.getAddAdmindata('modify', 'at');

    for (i = 0; i < nv.length; i++) {
        name = nv[i].name.toSqlHana(null, null, { withoutTable: true });
        name = name.substr(1, name.length - 2);
        appData[name] = {
            value: nv[i].value,
            sequence: null
        };

        if (modifyBy && name === 'MODIFIED_BY') {
            // overwrites .formula .sequence and .value
            nv[i].overwriteValue = new sqlStatement.Value(context.userName);
        }
        if (modifyAt && name === 'MODIFIED_AT') {
            nv[i].formula = 'NOW()';
        }
    }

    if (!(createBy || createAt)) {
        return asyncDone(null, context);
    }

    return insertOldDataToOldTable(context, asyncDone);
};


var insertOldDataToOldTable = function (context, asyncDone) {
    context.logger.silly('dataCollectorPost', 'insertOldDataToOldTable');

    var dbSeg = context.oData.dbSegmentLast;
    var stm = dbSeg.sql.stmContainer.selectCreateInfoFromTmpOld;
    var nv = dbSeg.sql.stmContainer.insertTmp.nv;
    var name;

    const createBy = dbSeg.entityType.getAddAdmindata('create', 'by');
    const createAt = dbSeg.entityType.getAddAdmindata('create', 'at');


    var p = [];
    var sql = stm.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), p);

    dataCollector2.executeSqlAsPreparedStatement(context, sql, p, (err, rows) => {
        if (err) {
            context.logger.info('SQL Exec', 'Error: \n' + JSON.stringify(err));
            context.logger.info('SQL Exec', 'SQL: \n' + sql);
            return asyncDone(new SqlError(context, err), context);
        }

        context.logger.silly('selectData', 'rows: ' + JSON.stringify(rows.length));

        for (let i = 0; i < nv.length; i++) {
            name = nv[i].name.toSqlHana(null, null, { withoutTable: true });
            name = name.substr(1, name.length - 2);

            if (createBy && name === 'CREATED_BY') {
                nv[i].value = new sqlStatement.Value(rows[0].CREATED_BY);
            }
            if (createAt && name === 'CREATED_AT') {
                nv[i].value = new sqlStatement.Value(rows[0].CREATED_AT);
            }
        }
        return asyncDone(null, context);

    });
};

exports.insertOldDataToOldTable = function (context, asyncDone) {
    var dbSeg = context.oData.dbSegmentLast;
    return statementProcessor.execStmsAsPreparedNoResult( context,dbSeg.sql.stmContainer.insertTmpOld, asyncDone);
};

exports.moveCreatedInfoToNewTempTable = function (context, asyncDone) {
    var dbSeg = context.oData.dbSegmentLast;
    statementProcessor.execStmsAsPreparedNoResult(context,dbSeg.sql.stmContainer.updateTmpCreateInfo, asyncDone);
};

exports.insertPayloadIntoTempTable = function (context, asyncDone) {
    context.logger.silly('dataCollectorPut', 'insertPayloadIntoTempTable');
    var dbSeg = context.oData.dbSegmentLast;
    statementProcessor.execStmsAsPreparedNoResult(context,dbSeg.sql.stmContainer.insertTmp, asyncDone);
};


exports.insertTmpTableToRealTable = function (context, asyncDone) {
    context.logger.silly('dataCollectorPut', 'insertTmpTableToRealTable');
    var dbSeg = context.oData.dbSegmentLast;

    statementProcessor.execStmsAsPrepared(context,[dbSeg.sql.stmContainer.updateReal],  (err, context, resultset) => {
        if (err) {
            return asyncDone(err, context);
        }
        return dataCollector2.resultSetCheckRowCountForUpdate(context, resultset, 0, 1, asyncDone);
    });
};

exports.selectData = function (context, asyncDone) {
    context.logger.silly('dataCollectorPost', 'selectData');
    var dbSeg = context.oData.dbSegmentLast;
    var stm = dbSeg.sql.stmContainer.selectFromTmp;

    var p = [];
    var sql = stm.toSqlHana(new sqlStatement.SqlBuildHanaContext(context), p);
    dataCollector2.executeSqlAsPreparedStatement(context,sql,p, (err, rows)=> {
            dbSeg.sql.rows = rows;
            if (rows.length === 1 && utils.isETagHeaderRequired(context, dbSeg)) {
                dbSeg.etagHeader = rows[0].__etag;
            }
            return asyncDone(null, context);
    });
};

exports.commit = function (context, asyncDone) {
    context.logger.debug('dataCollectorPut', 'commit');
    if (context.batchContext) {
        //When running in batch the commit is performed by the batch executor
        return asyncDone(null, context);
    }

    var client = context.db.client;
    client.commit(function (err) {
        if (err) {
            context.logger.info('SQL Exec', 'Commit Error: \n' + JSON.stringify(err));
            return asyncDone(err, context);
        }
        return asyncDone(null, context);
    });
};

/**
 * Executes truncation of temporary created tables
 *
 * @param {Object} context The xsodata context
 * @param {Function} asyncDone async waterfall callback
 */
exports.truncateTempTables = function (context, asyncDone) {
    var statements;
    context.logger.silly('dataCollectorPut', 'truncateTempTables');

    statements = [
        context.sql.container.createTmpTruncate,
        context.sql.container.createTmpOldTruncate
    ];
    return statementProcessor.execTempTableStatements(context,statements, asyncDone) ;
};

/**
 * Executes deletion of temporary created tables
 *
 * @param {Object} context The xsodata context
 * @param {Function} asyncDone async waterfall callback
 */
exports.dropTempTables = function (context, asyncDone) {
    var statements;
    context.logger.silly('dataCollectorPut', 'dropTempTables');

    statements = [
        context.sql.container.createTmpDrop,
        context.sql.container.createTmpOldDrop
    ];

    return statementProcessor.execTempTableStatements(context,statements, asyncDone) ;
};

