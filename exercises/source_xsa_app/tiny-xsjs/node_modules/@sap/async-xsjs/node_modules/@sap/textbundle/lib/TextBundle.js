'use strict';

var fs = require('fs');
var path = require('path');
var utils = require('./utils');
var PropertiesParser = require('./PropertiesParser');

/**
 * @classdesc TextBundle classes manages text resources for a given locale.
 * @param {string} [propertyFile] Path to the base text resource property file. If not provided, options.path is taken. Either propertyFile or options.path must be provided.
 * @param {string} [locale] Bundle locale (use of standard BCP 47 locales is recommended, POSIX is supported), default to 'en'.
 * 'propertyFile' argument is required to be able to pass locale as string argument.
 * @param {object} [options] Bundle options (for legacy compatibility).
 * @param {string} options.locale Bundle locale (for legacy compatibility).
 * @param {string} options.path Path to the base text resource property file (for legacy compatibility).
 * @property {string} locale TestBundle main locale
 * @constructor
 */
function TextBundle(propertyFile, locale, options) {
    if (typeof propertyFile === 'object') {
        options = propertyFile;
        propertyFile = options.path;
        locale = options.locale;
    }
    if (!propertyFile || typeof propertyFile !== 'string') {
        throw new TypeError('Missing or invalid base property file.');
    }
    this._pathinfo = _definePathInfo(propertyFile);
    // _locales uses POSIX locales whereas _locale could be either POSIX or BCP 47
    this._locale = locale || 'en';
    this._locales = [];
    this._propertyParsers = [];
}
module.exports = TextBundle;
TextBundle.prototype.logger = require('./defaultLogger');

/**
 * Returns the fallback of a given locale (e.g. 'fr_FR' => 'fr' => 'en' => '')
 * @private
 */
function fallbackLocale(locale) {
    var fallback, pos;
    // TODO: validate why, maybe remove? Introduced by Martin S.
    // keep in sync with fallback mechanism in Java, ABAP (MIME & BSP)
    // resource handler (Java: Peter M., MIME: Sebastian A., BSP: Silke A.)
    if (locale === 'zh_HK') {
        fallback = 'zh_TW';
    }
    else {
        pos = locale.lastIndexOf('_');
        if (pos >= 0) {
            fallback = locale.substring(0, pos);
        }
        else {
            fallback = (locale === 'en' ? '' : 'en');
        }
    }
    return fallback;
}

/**
 * Returns the fallback of a given locale (e.g. 'fr_FR' => 'fr' => 'en' => '')
 * @param {string} locale
 * @returns {string}
 */
TextBundle.fallbackLocale = fallbackLocale;

function nop() {}

function checkFileAccess(filename) {
    return new Promise(
        function (resolve, reject) {
            fs.open(filename, 'r', function (err, fd) {
                if (err) {
                    reject(err);
                }
                else {
                    fs.close(fd, nop);
                    resolve(true);
                }
            });
        });
}

function checkFileAccessSync(filename) {
    var fd = fs.openSync(filename, 'r');
    fs.closeSync(fd);
    return true;
}

function load(bundle, locale) {
    var pathVar = bundle._pathinfo.prefix + (locale ? '_' + locale : '') + bundle._pathinfo.extension;
    bundle.logger.debug('Loading property file %s', pathVar);
    return PropertiesParser.load(pathVar)
        .catch(function (err) {
            if (err.code === 'ENOENT') {
                // Do not throw an error if the resource file does not exist
                bundle.logger.info('No text bundle found for locale %s', locale);
                return null;
            }
            bundle.logger.error(err, 'Failed to load text bundle for locale %s', locale);
            throw err;
        });
}

function loadSync(bundle, locale) {
    var pathVar = bundle._pathinfo.prefix + (locale ? '_' + locale : '') + bundle._pathinfo.extension;
    try {
        bundle.logger.debug('Loading property file %s', pathVar);
        return PropertiesParser.loadSync(pathVar);
    }
    catch (err) {
        if (err.code === 'ENOENT') {
            // Do not throw an error if the resource file does not exist
            bundle.logger.info('No text bundle found for locale %s', locale);
            return null;
        }
        bundle.logger.error(err, 'Failed to load text bundle for locale %s', locale);
        throw err;
    }
}

function _definePathInfo(basePath) {
    var caller;
    if (!path.isAbsolute(basePath)) {
        caller = utils.callerLocation(2);
        basePath = path.resolve(path.dirname(caller), basePath);
    }
    var extension = path.extname(basePath) || '.properties';
    var prefix = path.join(path.dirname(basePath), path.basename(basePath, extension));

    return {
        path: prefix + extension,
        prefix: prefix,
        extension: extension
    };
}

/**
 * Returns the TextBundle main locale
 * @returns {string}
 */
TextBundle.prototype.getLocale = function () {
    return this._locale;
};

/**
 * Returns a formatted message for the given resource key and arguments
 * @param {string} key Resoruce key
 * @param {...object} [args]
 * @returns {string}
 */
TextBundle.prototype.getText = function (key, args) {
    var value = null,
        properties, i, tempLocale;

    // Loop over all loaded property files and return the value for the key.
    if (!this._locales.length) {
        this.loadSync();
    }
    for (i = 0; i < this._propertyParsers.length; i++) {
        tempLocale = this._locales[i];
        properties = this._propertyParsers[i];
        value = properties && properties.getProperty(key);
        if (typeof value === 'string') {
            break;
        }
        this.logger.debug('Message not found for key "%s" and locale %s', key, tempLocale);
    }

    // Value for this key was not found in the currently loaded property files, load synchronously the fallback locales.
    // Should integrate it with express module in the future, so we can get region.
    if (typeof value !== 'string') {

        while (tempLocale.length > 0) {
            tempLocale = fallbackLocale(tempLocale);
            properties = loadSync(this, tempLocale);

            // Push a null property parser if the resource file does not exist to avoid repeatedly looking up for the missing file
            this._locales.push(tempLocale);
            this._propertyParsers.push(properties);
            if (properties === null) {
                continue;
            }

            // check whether the key is included in the newly loaded property file
            value = properties.getProperty(key);
            if (typeof value === 'string') {
                break;
            }
        }
    }

    if (typeof value !== 'string') {
        value = key;
    }
    return (args ? utils.formatMessage(value, args) : value);
};

/**
 * Asynchronously loads a bundle resources (including the full fallback chain)
 * @return {Promise} Promise eventually fulfilled to the bundle.
 */
TextBundle.prototype.load = function () {
    var self = this;

    function loadLocale(locale, index) {
        if (self._locales[index] === locale) {
            // Locale already loaded
            return Promise.resolve(true);
        }
        return load(self, locale)
            .then(function (properties) {
                self._locales[index] = locale;
                self._propertyParsers[index] = properties;
            });
    }

    return checkFileAccess(this._pathinfo.path)
        .then(function () {
            var i, promises = [],
                tempLocale = utils.normalize(self._locale);
            promises.push(loadLocale(tempLocale, 0));
            for (i = 1; tempLocale.length > 0; ++i) {
                tempLocale = fallbackLocale(tempLocale);
                promises.push(loadLocale(tempLocale, i));
            }
            return Promise.all(promises)
                .then(function () {
                    return self;
                })
                .catch(function (err) {
                    self.logger.error(err, 'Failed to load text resources');
                    throw err;
                });
        }, function (err) {
            self.logger.error(err, 'Failed to access base resource file');
            throw err;
        });
};

/**
 * Synchronously loads a bundle resources for its main locale (without the fallback chain)
 */
TextBundle.prototype.loadSync = function () {
    var locale = utils.normalize(this._locale);
    if (this._locales[0] !== locale) {
        this.logger.debug('Loading test resources for bundle main locale %s', locale);
        try {
            checkFileAccessSync(this._pathinfo.path);
        }
        catch (err) {
            this.logger.error(err, 'Failed to access base resource file');
            throw err;
        }
        this._locales = [locale];
        this._propertyParsers = [loadSync(this, locale)];
    }
    return this._propertyParsers[0];
};

Object.defineProperties(TextBundle.prototype, {
    locale: {
        get: TextBundle.prototype.getLocale
    }
});
