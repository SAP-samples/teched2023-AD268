const CsrfTokenRequest = require('./CsrfTokenRequest');
const Url = require('url').URL;

const UnsupportedRedirectionError = require('./UnsupportedRedirectionError');

const requestOptionPropertiesBlacklist = ['path', 'pathname', 'host', 'hostname', 'search', 'searchParams', 'protocol', 'port', '_parsedURL'];
const responseHeadersWhiteList = [];

class RedirectedRequest extends CsrfTokenRequest {

    constructor(options, currentRedirectCounter = 0) {

        super(options);
        this._currentRedirectCounter = currentRedirectCounter;

        if (options.followRedirect !== undefined &&
            typeof options.followRedirect !== 'number' &&
            typeof options.followRedirect !== 'function' &&
            typeof options.followRedirect !== 'boolean') {
            throw new Error(`Invalid redirect option: ${options.followRedirect}`);
        }

        this._followHostForwarding = options.followHostForwarding === true;
        this._followRedirect = (options.followRedirect !== undefined) ? options.followRedirect : true;
    }

    _assertSupportedRedirect(response) {
        if (response.statusCode >= 300 && response.statusCode <= 399) {
            if ([301, 302, 307, 308].includes(response.statusCode)) {
                if (!response.headers.location) {
                    throw new UnsupportedRedirectionError('Header \'location\' missing on redirect');
                }
                return true;
            } else {
                throw new UnsupportedRedirectionError(`Request was redirected and failed because of unsupported response status code: ${response.statusCode}'`);
            }
        }
        return false;
    }

    async _redirect(response) {
        this._currentRedirectCounter += 1;

        if (typeof this._followRedirect === 'function' && !this._followRedirect(response)) {
            throw new UnsupportedRedirectionError(`Following the redirect to location '${response.headers['location']}' is not allowed`);
        }

        if (typeof this._followRedirect === 'number' && this._currentRedirectCounter > this._followRedirect) {
            throw new UnsupportedRedirectionError(`Maximum number of redirects reached (${this._followRedirect})`);
        }

        if (this._currentRedirectCounter > 10) throw new UnsupportedRedirectionError('Maximum Number of 10 redirects reached!');

        const locationHeaderValue = response.headers && response.headers.location;
        if (!locationHeaderValue) {
            throw new UnsupportedRedirectionError(`redirect status ${response.statusCode} enforces a 'location' header which is not present in the response`);
        }

        const redirectOptions = JSON.parse(JSON.stringify(this.getOptions()), (key, value) => {
            return requestOptionPropertiesBlacklist.includes(key) ? undefined : value;
        });

        responseHeadersWhiteList.forEach((headerName) => {
            if (response.headers[headerName]) redirectOptions.headers[headerName] = response.headers[headerName];
        });

        let targetHost;

        try {
            // First try to use location as a valid url
            // Be aware: This allows url forwarding to another domain if the location header includes another domain
            // this is controlled by flag this._followHostForwarding
            const locationUrl = new Url(locationHeaderValue);
            redirectOptions.url = locationUrl.href;
            targetHost = locationUrl.host;
        } catch (error) {
            // If location is not an absolute url we try to use as relative url.
            // This could throw "Invalid Url" - error if the result would be still not a valid url
            const relativeUrl = new Url(locationHeaderValue, this.getOptions().url);
            redirectOptions.url = relativeUrl.href;
            targetHost = relativeUrl.host;
        }

        if (this._followHostForwarding !== true) {
            const originHost = this.getURL().host;
            if (targetHost !== originHost) {
                throw new UnsupportedRedirectionError(`Invalid target host '${targetHost}' for redirection. Host forwarding on redirect in not allowed`);
            }
        }

        redirectOptions.followRedirect = this._followRedirect;
        redirectOptions.cookies = this._cookies;
        redirectOptions.followHostForwarding = this._followHostForwarding;

        return await new RedirectedRequest(redirectOptions, this._currentRedirectCounter).execute();
    }

    /**
     * Executes the request
     *
     * @returns {object} response - The http response
     * @throws Throws an error if the request fails. the error may has an .response property.
     */
    async execute() {

        const response = await super.execute();

        if (!this._followRedirect) {
            return response;
        }

        try {
            if (this._assertSupportedRedirect(response)) {
                return await this._redirect(response);
            }
        } catch (error) {
            error.response = response;
            throw error;
        }

        return response;
    }
}

module.exports = RedirectedRequest;

