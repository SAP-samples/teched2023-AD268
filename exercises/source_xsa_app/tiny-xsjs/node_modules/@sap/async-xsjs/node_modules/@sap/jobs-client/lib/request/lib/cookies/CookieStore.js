
const setCookie = require('set-cookie-parser');
const EventEmitter = require('events').EventEmitter;
const SetTimeout = require('../SetTimeout');

const globalCookies = new Map();

class Cookie extends EventEmitter {

    constructor(cookieInfo) {
        super();
        this._cookieInfo = cookieInfo;

        if (cookieInfo.expires) {
            this._expireTimer = new SetTimeout((_this) => {
                this.emit('expire', _this);
            }, cookieInfo.expires - Date.now()).start(this);
        }
    }

    getId() { return this.getDomain() + this.getPath(); }

    getDomain() { return this._cookieInfo.domain; }
    getPath() { return this._cookieInfo.path; }
    getName() { return this._cookieInfo.name; }
    getValue() { return this._cookieInfo.value; }
    getExpires() { return this._cookieInfo.expires; }
}

/**
 * A CookieStore to be used as `reqOptions.cookies.cookieStore`.
 * The npm module set-cookie-parser has to be installed by the application in order to use this class.
 * It is not included as dependency in request so that apps using requests without cookies are not affected, in particular node-jobs-client.
 */
class CookieStore {

    clear() {
        globalCookies.clear();
        return this;
    }

    delete(cookie) {
        const domainCookies = globalCookies.get(cookie.getDomain());
        if (domainCookies) {
            const pathCookies = domainCookies.get(cookie.getPath());
            if (pathCookies) {
                pathCookies.delete(cookie.getName());
                if (pathCookies.size === 0) {
                    domainCookies.delete(cookie.getPath());
                }
            }
            if (domainCookies.size === 0) {
                globalCookies.delete(cookie.getDomain());
            }
        }
    }

    buildCookieHeader(cookies) {

        if (!cookies || !Array.isArray(cookies) || cookies.length === 0) return {};

        return {
            cookie: cookies.map((cookie) => {
                return cookie.getName() + '=' + cookie.getValue();
            }).join('; ')
        };
    }


    addCookies(response, request) {

        if (!response.headers || !response.headers['set-cookie']) return this;

        const setCookieHeaders = response.headers['set-cookie'];
        if (!Array.isArray(setCookieHeaders)) {
            throw new Error(`Received 'set-cookie' is not an array: ${setCookieHeaders}`);
        }
        for (let i = 0; i < setCookieHeaders.length; i++) {
            const parsedCookie = setCookie.parseString(setCookieHeaders[i], { decodeValues: false });
            let cookieInfo = {};
            cookieInfo.name = parsedCookie.name;
            cookieInfo.value = parsedCookie.value;
            if (parsedCookie.path && parsedCookie.path !== '/') {
                cookieInfo.path = parsedCookie.path;
            } else {
                cookieInfo.path = '';
            }
            if (parsedCookie.domain) {
                // RFC6265:
                // Let cookie-domain be the attribute-value without the leading %x2E (".") character.
                // Convert the cookie-domain to lower case.
                if (parsedCookie.domain[0] === '.') {
                    parsedCookie.domain = parsedCookie.domain.substring(1);
                }
                cookieInfo.domain = parsedCookie.domain.toLowerCase();
            } else {
                cookieInfo.domain = request.hostname || request.host;
            }

            if (parsedCookie.maxAge) {
                // RFC6265: If a cookie has both the Max-Age and the Expires attribute,
                // the Max-Age attribute has precedence and controls the expiration date of the cookie.
                cookieInfo.expires = Date.now() + parsedCookie.maxAge * 1000;
            } else if (parsedCookie.expires) {
                cookieInfo.expires = Date.parse(parsedCookie.expires);
            } else {
                cookieInfo.expires = null;
            }
            const cookie = new Cookie(cookieInfo);

            const domain = cookie.getDomain();
            const path = cookie.getPath();
            const name = cookie.getName();

            if (!globalCookies.has(domain)) {
                globalCookies.set(domain, new Map());
            }
            const existingDomainCookies = globalCookies.get(domain);

            if (!existingDomainCookies.has(path)) {
                existingDomainCookies.set(path, new Map());
            }
            const existingPathCookies = existingDomainCookies.get(path);
            // RFC6265 5.3 - 11.:
            // Steps 1-3 are ommitted since we do not save the cookie creation time or http-only flag
            // Step 4 is implicitely done by overwriting the cookie.
            existingPathCookies.set(name, cookie);

            if (cookieInfo.expires) {
                cookie.on('expire', (_cookie) => {
                    this.delete(_cookie);
                });
            }
        }
    }

    getCookies(options) {

        let host = '';
        let path = '';

        if (options.hostname) {
            host = options.hostname.toLowerCase();
        }
        if (!host && options.host) {
            host = options.host.toLowerCase();
        }
        if (!host) {
            host = 'localhost';
        }
        if (options.pathname) {
            path = options.pathname;
        }

        const getCookies = (domain, path) => {
            const domainCookies = globalCookies.get(domain);
            if (!domainCookies) return [];
            const pathCookies = domainCookies.get(path || '');
            if (!pathCookies) return [];
            return [...pathCookies.values()];
        };

        let cookies = []
            .concat(getCookies(options.hostname))
            .concat(getCookies(host))
            .concat(getCookies(host, path));

        const hostComponents = host.split('.');
        let hostComponent = '';
        for (let i = hostComponents.length - 1; i > 0; i--) {
            if (!hostComponent) {
                hostComponent = hostComponents[i];
            } else {
                hostComponent = hostComponents[i].concat('.').concat(hostComponent);
            }
            if (host !== hostComponent) {
                cookies = cookies.concat(getCookies(hostComponent));
                if (path) {        // avoid duplicates!
                    cookies = cookies.concat(getCookies(hostComponent, path));
                }
            }
        }

        const resultCookies = new Set();
        cookies
            .filter((cookie) => { return !!cookie; })
            .forEach((cookie) => { resultCookies.add(cookie); });

        return Array.from(resultCookies.values());

    }

    static getInstance() {
        if (!CookieStore._instance) CookieStore._instance = new CookieStore();
        return CookieStore._instance;
    }
}


module.exports = CookieStore;