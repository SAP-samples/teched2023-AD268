const Url = require('url').URL;
const URLSearchParams = require('url').URLSearchParams;
const http = require('http');
const https = require('https');

class PlainRequest {

    static buildOptions(options) {

        const _options = {};

        const url = new Url(options.url);       // url is required!

        _options._parsedURL = url;
        _options.url = options.url;
        _options.host = url.host;
        _options.hostname = url.hostname;
        _options.pathname = url.pathname;
        _options.port = url.port;
        _options.protocol = url.protocol;
        _options.search = url.search;
        _options.searchParams = url.searchParams;

        if (options.qs) {
            new URLSearchParams(options.qs).forEach((value, name) => {
                _options.searchParams.append(name, value);
            });
        }

        if (!options.path) _options.path = `${url.pathname}${url.search}`;
        if (options.followRedirect) _options.followRedirect = options.followRedirect;
        if (options.retry) _options.retry = options.retry;
        if (options.auth) _options.auth = options.auth;
        if (options.oauth) _options.oauth = options.oauth;
        if (options.basic) _options.basic = options.basic;
        if (options.csrf) _options.csrf = options.csrf;
        if (options.headers) _options.headers = options.headers;
        if (options.body) _options.body = options.body;
        if (options.form) _options.form = options.form;
        if (options.timeout) _options.timeout = options.timeout;
        if (options.cert) _options.cert = options.cert;
        if (options.key) _options.key = options.key;
        if (options.ca) _options.ca = options.ca;
        if (options.ciphers) _options.ciphers = options.ciphers;
        if (options.passphrase) _options.passphrase = options.passphrase;
        if (options.rejectUnauthorized) _options.rejectUnauthorized = options.rejectUnauthorized;
        if (Number.isSafeInteger(options.responseTimeout) && options.responseTimeout > 0) {
            _options.responseTimeout = options.responseTimeout;
        }

        _options.method = options.method || 'GET';

        return _options;
    }

    constructor(options) {

        if (!options) {
            throw new Error('Config parameter cannot be undefined');
        }
        this._options = PlainRequest.buildOptions(options);
    }

    getOptions() {
        return this._options;
    }

    getURL() {
        return this.getOptions()._parsedURL;
    }

    _writeBody(request) {
        let body = null;
        if (this._options.body) {
            if (typeof this._options.body === 'string') {
                request.setHeader('content-type', 'text/plain');
                body = this._options.body;
            }
            else if (typeof this._options.body === 'object' || typeof this._options.json === 'object') {
                request.setHeader('content-type', 'application/json');
                body = JSON.stringify(this._options.body || this._options.json, null, 0);
            }
        }
        else if (this._options.form) {
            if (typeof this._options.form === 'object') {
                body = new URLSearchParams(this._options.form).toString();
                request.setHeader('content-type', 'application/x-www-form-urlencoded');
            }
        }

        if(body) {
            request.setHeader('content-length', Buffer.byteLength(body));
            request.write(body);
        }
    }

    /**
     * Executes the request
     *
     * @returns {object} response - The http response
     * @throws Throws an error if the request fails. the error may has an .response property.
     */
    async execute() {

        const httpModule = this._options.protocol === 'https:' ? https : http;

        return new Promise((resolve, reject) => {
            let ended = false;

            const request = httpModule
                .request(this._options, (response) => {
                    response
                        .on('data', (chunk) => {
                            if (!response.text) response.text = '';
                            if (chunk !== undefined) response.text += chunk.toString();
                        })
                        .on('end', () => {
                            ended = true;
                            clearTimeout(this._responseTimeout);
                            const _response = {
                                statusCode: response.statusCode,
                                headers: response.headers || {},
                                text: response.text
                            };

                            try {
                                _response.body = JSON.parse(_response.text);
                            } catch (error) {
                                // ignore because it can be that data is not json
                            }

                            resolve(_response);
                        })
                        .on('close', () => {
                            if (!ended) {
                                response.emit('end');
                            }
                        });
                })
                .on('error', (error) => {
                    ended = true;
                    clearTimeout(this._responseTimeout);
                    reject(error);
                })
                .on('timeout', (error) => {
                    // Clear timout of this._responseTimeout is not needed because request.destroy(error) fires the 'error' event
                    // There the timeout is cleared
                    if (!error) {
                        error = new Error(`Socket timeout after ${this._options.timeout} ms`);
                        error.code = 'ESOCKETTIMEDOUT';
                    }
                    request.destroy(error);
                });

            if (this._options && this._options.responseTimeout) {
                // request.setTimeout(...) does not work as expected. Therefore we have an internal timer
                this._responseTimeout = setTimeout(() => {
                    const error = new Error(`Response timeout after ${this._options.responseTimeout} ms`);
                    error.code = 'ERR_RESPONSE_TIMEDOUT';
                    request.emit('timeout', error);
                }, this._options.responseTimeout).unref();
            }

            this._writeBody(request);

            request.end();
        });
    }
}

module.exports = PlainRequest;

