/* Parses and OData 2.0 $segment expression */


/* first token match wins , use %options flex to use longest match*/

/***** start lexer ****/

%lex

/***** definitions ****/

DIG         [0-9]
H			[a-fA-F0-9]
QUOTE       \'

%%

/***** rules **********/

\s+                   /* whitespaces*/

null                  return 'null'
nil                   return 'nil'
true                  return 'true'
false                 return 'false'
{DIG}+"."{DIG}+("E"|"e")("-"|"+")?{DIG}+("F"|"f"|"D"|"d"|"M"|"m"|"L"|"l")   return 'digits4'
//{DIG}+"."{DIG}+("E"|"e"){DIG}+("F"|"f"|"D"|"d"|"M"|"m"|"L"|"l")   return 'digits4'
{DIG}+"."{DIG}+("F"|"f"|"D"|"d"|"M"|"m"|"L"|"l")                  return 'digits3'
{DIG}+("F"|"f"|"D"|"d"|"M"|"m"|"L"|"l")                           return 'digits2'
{DIG}+                                                            return 'digits1'


/*edm types*/
("X"|"binary"){QUOTE}({H}{H})*{QUOTE}
    return 'binary';

"guid"{QUOTE}{H}{H}{H}{H}{H}{H}{H}{H}"-"{H}{H}{H}{H}"-"{H}{H}{H}{H}"-"{H}{H}{H}{H}{H}{H}{H}{H}{H}{H}{H}{H}{QUOTE}
    return 'guid';

"datetime"{QUOTE}{DIG}{DIG}{DIG}{DIG}"-"{DIG}{DIG}?"-"{DIG}{DIG}?"T"{DIG}{DIG}?":"{DIG}{DIG}(":"{DIG}{DIG}("."{DIG}+)?)?{QUOTE}
    return 'datetime';
"time"{QUOTE}"P"({DIG}{DIG}?{DIG}?{DIG}?"Y")?({DIG}{DIG}?"M")?({DIG}{DIG}?"D")?"T"({DIG}{DIG}?"H")?({DIG}{DIG}?"M")?({DIG}?{DIG}?("."{DIG}+)?"S")?{QUOTE}
    return 'time';

"-"    return "-";
"("    return '('
")"    return ')'
","    return ",";
"="    return "=";

"$metadata"          return 'metadata'
"$batch"             return 'batch'
"$count"             return 'count'
"$value"             return 'value'
"$links"             return 'links'

\'([^\']|\'\')*\'       return 'string';

/* According to Odata CSDL Spec, hyphens are not allowed for OData Indentifiers.
However, in XS Classic hyphen's are allowed. Hence, due to compatibility with XSC XSOData services,
we also allow hyphens, e.g. for EntitySet names.
Service developers must be aware, that services using hyphens may not be compatible with each client. */

[a-zA-Z]([a-zA-Z0-9_-])*  return 'property';


/* don't parse garbage at filters end */
<<EOF>>                 return 'EOF'

/lex

/***** start expressions ******/

%start segment

%% /* language grammar */

number
    :   digits1
        {
        $$ = new edm.Number($1);
        }
    |   digits2
        {
        $$ = new edm.Number($1);
        }
    |   digits3
        {
        $$ = new edm.Number($1);
        }
    |   digits4
        {
        $$ = new edm.Number($1);
        }
    ;

literal
    :   true
        {$$ = new edm.Boolean(true);}
    |   false
        {$$ = new edm.Boolean(false);}
    |   nil
        {
            $$ = new edm.Nil();
            // nil values are not used by the client, but for resolving contentIds in the create tmp table step
            // (for keys which are filled later via sequence), nil values are used temporary to allow uri parsing
        }
    |   number
        {$$ = $1;}
    |   "-" number {
            $2.sign = $2.sign * -1;
            $$ = $2;
        }
    |   binary
        {$$ = new edm.Binary($1);}
    |   guid
        {$$ = new edm.Guid($1);}
    |   datetime
        {$$ = new edm.DateTime($1);}
    |   time
        {$$ = new edm.Time($1);}
    |   string
        {$$ = new edm.EdmString($1);}
    ;

segment
    :   literal EOF
        {return $1;}
    ;

%%


var edm = require('./../utils/typedObjects');
var utils = require('./../uri/uriSegmentTypes');
