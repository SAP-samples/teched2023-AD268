'use strict';
const destinationUtils = require('../../lib/utils/destination-utils');
const tokenUtils = require('../../lib/utils/token-utils');
const jwtDecode = require('jwt-decode');
const expiresAt = require('../passport/utils').getExpiresAt;
const validators = require('../configuration/validators');
const passportUtils = require('../passport/utils');
const sessionExt = require('../utils/session-ext');

const self = module.exports = {
  NO_DESTINATION_FLOW: 0,
  ENV_DESTINATION_FLOW: 1,
  SVC_DESTINATION_FLOW: 2,
  retrieveDestination: function (options, cb) {
    self.replaceUserToken(options, function (err, userExchangeToken) {
      if (err) {
        return cb(err);
      }
      let destinationName = options.destinationName;
      let accessToken = userExchangeToken && userExchangeToken.access_token ? userExchangeToken.access_token : userExchangeToken;
      destinationUtils.findDestination(destinationName, accessToken, options, function (err, destinationLookUpResult) {
        if (err) {
          return cb(err);
        }
        try {
          if (!destinationLookUpResult || !destinationLookUpResult.destinationConfiguration) {
            return cb('Cannot get destination configuration for destination ' + destinationName);
          }
          if (destinationLookUpResult.authTokens && destinationLookUpResult.authTokens[0].hasOwnProperty('error')) {
            return cb(destinationLookUpResult.authTokens[0].error);
          }
          if (destinationLookUpResult.authTokens) {
            const authTokenExpiresIn = destinationLookUpResult.authTokens[0].expires_in;
            destinationLookUpResult.authTokens[0].expireDate = authTokenExpiresIn ? expiresAt(authTokenExpiresIn).getTime() : 0;
          }
          let result = {};
          if (userExchangeToken) {
            const tokenDecoded = jwtDecode(userExchangeToken);
            const expMs = tokenDecoded.exp * 1000;
            const threeMins = 180000;
            result.userExchangeToken = {
              token: userExchangeToken,
              expireDate: expMs > threeMins ? expMs - threeMins : expMs,
              destinationKey: options.destinationKey
            };
          }
          let destinationsConfigurations = [destinationLookUpResult.destinationConfiguration];
          destinationUtils.normalizeDestinationProperties(destinationsConfigurations);
          const normalizedCertificateProperties = destinationUtils.isDestinationCertificatesFlow(destinationsConfigurations[0])
              && destinationUtils.normalizeCertificateProperties(destinationLookUpResult.certificates);
          validators.validateDestinations(destinationsConfigurations);
          destinationUtils.adjustDestinationProperties(destinationsConfigurations);
          result.destination = destinationsConfigurations[0];
          result.expireDate = destinationLookUpResult.authTokens && destinationLookUpResult.authTokens[0].expireDate;
          if (options.dynamicDestination && !result.destination.dynamicDestination) {
            return cb('Destination ' + destinationName + ' is not defined as a dynamic destination in destination service, configure additional property HTML5.DynamicDestination true');
          }
          result.authToken = destinationLookUpResult.authTokens ? destinationLookUpResult.authTokens[0] : null;
          result.destination.certificates = normalizedCertificateProperties && destinationUtils.getDestinationCertificate(destinationsConfigurations[0], normalizedCertificateProperties);
          return cb(null, result);
        } catch (error) {
          return cb(error);
        }
      });
    });
  },

  getDestinationFlowType: function (internalUrl) {
    const destinationName = internalUrl && internalUrl.route && internalUrl.route.destination;
    const destinationObj  = internalUrl && internalUrl.destination;
    if (!destinationName || !destinationObj) {
      return self.NO_DESTINATION_FLOW;
    }
    if (destinationObj.url === 'DESTINATION_URL_PLACEHOLDER') {
      return self.SVC_DESTINATION_FLOW;
    }
    return self.ENV_DESTINATION_FLOW;
  },

  replaceUserToken: function (options, cb) {
    let session = options.session;
    if (!session || !session.user || session.user.name === passportUtils.USER_NAME_NOT_APPLICABLE) {
      return cb(null);
    }
    shouldRequestUserExchangeToken(session, options.destinationKey, function (err, askForToken) {
      if (err) {
        return cb(err);
      }
      if (!askForToken) {
        let userExchangeToken = options.destinationKey && session.user.destinationKey && session.user.destinationKey[options.destinationKey]
          ? session.user.destinationKey[options.destinationKey].destinationUserExchangeToken.token : session.user.destinationUserExchangeToken.token;
        return cb(null, userExchangeToken);
      }
      getExternalServiceCredentials(options, (err, externalServiceCredentials) => {
        if (err) {
          return cb('Failed to get external service credentials ' + err);
        }
        if (!options.session.user.token) {
          return cb(`Missing token for session user. correlationId: ${options.correlationId}`);
        }
        let jwt = options.jwt || options.session.user.token.accessToken;
        return tokenUtils.exchangeToken(jwt, options.correlationId, externalServiceCredentials, cb);
      });
    });
  },
  addDestinationHeaders: function (req) {
    if (req.headers && req.internalUrl && req.internalUrl.destination) {
      const escapeHeaders = Object.keys(req.headers);
      for (const destinationKey in req.internalUrl.destination) {
        if (destinationKey.startsWith('uRL.headers')) {
          const headerKey = destinationKey.split('.')[2];
          if (headerKey && !escapeHeaders.includes(headerKey)) {
            req.headers[headerKey] = req.internalUrl.destination[destinationKey];
          }
        }
      }
    }
    return req;
  },
  getIASTokenByIASDependencyName: async function(options) {
    const IASDependencyName = (options.internalUrl && options.internalUrl.destination && options.internalUrl.destination.IASDependencyName) ||
        options.IASDependencyName;
    const loginIdToken = options.session && options.session.user && options.session.user.token && options.session.user.token.idToken;
    if (IASDependencyName && loginIdToken && options.zoneInfo){
      let token = options.session.user.iasDependencies &&
          options.session.user.iasDependencies[IASDependencyName] && options.session.user.iasDependencies[IASDependencyName].token;
      const currentTimestamp = Math.floor(Date.now() / 1000);
      if (token && token.expiresAt > currentTimestamp){
        return token.accessToken;
      }
      const credentials = options.session.user.token.oauthOptions;
      credentials.tokenEndPoint = options.zoneInfo.tokenEndpoint;
      credentials.apptid = options.zoneInfo.zoneId;
      token = await tokenUtils.getApp2AppToken(loginIdToken, credentials, IASDependencyName, options.correlationId);
      // eslint-disable-next-line no-unused-vars
      sessionExt.update(options.session, function(session) {
        if (!session.user.iasDependencies){
          session.user.iasDependencies = {};
        }
        session.user.iasDependencies[IASDependencyName] = {
          token: {
            idToken: token.id_token,
            accessToken: token.access_token,
            expiresAt: token.expires_in + Date.now() - 5
          }
        };
      });
      return token.access_token;
    }}
};

function shouldRequestUserExchangeToken(session, destinationKey, cb) {
  let destinationTokensCache = destinationKey && session.user.destinationKey && session.user.destinationKey[destinationKey]
    ? session.user.destinationKey[destinationKey].destinationUserExchangeToken : session.user.destinationUserExchangeToken;

  // check the expiration of destinationUserExchangeToken
  if (!destinationTokensCache || (destinationKey && (destinationKey !== destinationTokensCache.destinationKey)) || (!destinationTokensCache.token || destinationTokensCache.expireDate < Date.now())) {
    return cb(null, true);
  }
  return cb(null, false);
}

function getExternalServiceCredentials(options, cb){
  let externalServiceCredentials;
  if (options.destinationKey && options.app && options.app.services[options.destinationKey]) {
    destinationUtils.getDestinationCredentialsByDestinationKey(options.app, options.destinationKey, options.correlationId, (err, destCredentials) => {
      if (err) {
        return cb(err);
      }
      externalServiceCredentials = destCredentials;
      externalServiceCredentials.url = externalServiceCredentials.tokenServiceURL;
      externalServiceCredentials.clientid = externalServiceCredentials.clientId;
      externalServiceCredentials.clientsecret = externalServiceCredentials.clientSecret;
      return cb(null, externalServiceCredentials);
    });
  } else {
    externalServiceCredentials = options.destinationCredentials || destinationUtils.getDestinationServiceCredentials();
    cb(null, externalServiceCredentials);
  }
}