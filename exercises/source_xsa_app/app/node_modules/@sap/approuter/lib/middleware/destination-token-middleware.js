'use strict';

const url = require('url');
const destinationTokenHandler = require('./destination-token-handler');
const sessionExt = require('../utils/session-ext');
const headerUtils = require('../utils/header-util');
const passportUtils = require('../passport/utils');

module.exports = async function (req, res, next) {
  const destinationFlowType = destinationTokenHandler.getDestinationFlowType(req.internalUrl);
  if (destinationFlowType === destinationTokenHandler.NO_DESTINATION_FLOW) {
    return next();
  }
  const destinationCredentials = req.destinationCredentials && req.destinationCredentials.destination;
  const route = req.internalUrl.route;
  let options = {
    destinationName: route && route.destination,
    logger: req.logger,
    preferLocal: route && route.preferLocal,
    session: req.session,
    app: req.app,
    dynamicDestination:req.internalUrl.destination.dynamicDestination,
    destinationKey: req.destinationKey || (destinationCredentials && destinationCredentials.instanceid),
    destinationCredentials: destinationCredentials,
    urlTenant: passportUtils.getUrlTenant(req),
    correlationId: headerUtils.getCorrelationId(req),
    internalUrl: req.internalUrl,
    zoneInfo: req.zoneInfo
  };

  if (destinationFlowType === destinationTokenHandler.ENV_DESTINATION_FLOW){
    const err = await addExchangedIASToken(options, req);
    return next(err);
  }

  if (req.routerConfig && req.routerConfig.getToken) {
    req.routerConfig.getToken(req, function (err, jwt) {
      if (err) {
        return next(err);
      } else {
        options.jwt = jwt;
        return getDestination (req, res, options, next);
      }
    });
  } else {
    return getDestination (req, res, options, next);
  }
};

async function getDestination (req, res, options, next){
  const key = options.destinationKey ? options.destinationKey + '-' + options.destinationName : options.destinationName;
  let IASExchangeOptions;
  let cachedDestination = getCachedDestination(req, key, options.destinationName);
  if (cachedDestination){
    updateInternalUrl(req,cachedDestination.destinationConfiguration);
    IASExchangeOptions = {
      IASDependencyName: cachedDestination.destinationConfiguration.iASDependencyName,
      zoneInfo: req.zoneInfo,
      session: req.session,
      correlationId: headerUtils.getCorrelationId(req)
    };
    const error = await addExchangedIASToken(IASExchangeOptions, req);
    if (error) {
      return next(error);
    }
    destinationTokenHandler.addDestinationHeaders(req);
    return next();
  }
  options.correlationId = headerUtils.getCorrelationId(req);
  return destinationTokenHandler.retrieveDestination(options, async function (err, result) {
    if (err) {
      return next(err);
    }
    updateInternalUrl(req, result.destination); // normalized destination lookup result
    destinationTokenHandler.addDestinationHeaders(req);
    if (!req.session || !req.session.user){
      if (result.authToken){
        req.internalUrl.route['authToken'] = result.authToken;
      }
      return next();
    }
    IASExchangeOptions = {
      IASDependencyName: result.destination.iASDependencyName,
      zoneInfo: req.zoneInfo,
      session: req.session,
      correlationId: headerUtils.getCorrelationId(req)
    };
    const error = await addExchangedIASToken(IASExchangeOptions, req);
    if (error) {
      return next(error);
    }

    sessionExt.update(req.session, function(// eslint-disable-next-line
        session) {
      if (!req.session.user.destinations){
        req.session.user.destinations = {};
      }
      if (!req.session.user.destinationUserExchangeToken){
        req.session.user.destinationUserExchangeToken = {};
      }
      if (!req.session.user.destinations[key]){
        req.session.user.destinations[key] = {};
      }
      if (result.authToken && !req.session.user.destinations[key].authToken){
        req.session.user.destinations[key].authToken = {};
      }
      if (result.authToken) {
        req.session.user.destinations[key].authToken = result.authToken;
      }
      req.session.user.destinations[key].expireDate = result.expireDate;
      req.session.user.destinations[key].destinationConfiguration = result.destination;

      if (result.userExchangeToken) {
        if (req.destinationKey){
          if (!req.session.user.destinationKey){
            req.session.user.destinationKey = {};
          }
          req.session.user.destinationKey[req.destinationKey] = { destinationUserExchangeToken: result.userExchangeToken};
        } else {
          req.session.user.destinationUserExchangeToken = result.userExchangeToken;
        }
      }
    });
    return next();
  });
}

function updateInternalUrl (req, destination) {
  let destinationUrl = req.internalUrl.destination.url;
  let newHref = destination.url;
  // Avoid double slash between destination url and path
  if (newHref[newHref.length - 1] === '/') {
    destinationUrl += '/';
  }
  req.internalUrl.href = req.internalUrl.href.replace(destinationUrl, newHref);
  let newParsedUrl = new url.URL(req.internalUrl.href);
  req.internalUrl.protocol = newParsedUrl.protocol;
  req.internalUrl.host = newParsedUrl.host;
  req.internalUrl.hostname = newParsedUrl.hostname;
  req.internalUrl.pathname = newParsedUrl.pathname;
  req.internalUrl.path = newParsedUrl.pathname + newParsedUrl.search;
  req.internalUrl.port = newParsedUrl.port;
  req.internalUrl.destination = destination;
}

function getCachedDestination(req, key, destinationName){
  let destination = req.session && req.session.user && req.session.user.destinations && req.session.user.destinations[key];
  if (destination && ((destination.destinationConfiguration.authentication === 'BasicAuthentication'
          || destination.destinationConfiguration.authentication === 'NoAuthentication') ||
      (destination.expireDate && destination.expireDate - Date.now() > 0))){
    const logger  = req.loggingContext.getLogger('/Destination service');
    logger.info('Destination ' + destinationName + ' has been retrieved from cache');
    return destination;
  } else {
    return null;
  }
}

async function addExchangedIASToken(options, req){
  try {
    const IASToken = await destinationTokenHandler.getIASTokenByIASDependencyName(options);
    if (IASToken){
      req.internalUrl.route['authToken'] = {
        // eslint-disable-next-line camelcase
        http_header : {
          key: 'Authorization',
          value: 'Bearer ' +  IASToken
        }
      };
    }
  } catch (err){
    return err;
  }
  return null;
}